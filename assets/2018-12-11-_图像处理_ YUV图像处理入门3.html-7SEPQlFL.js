const t=JSON.parse(`{"key":"v-026e4458","path":"/blog/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/YUV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/2018-12-11-_%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%20YUV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A83.html","title":"[图像处理] YUV图像处理入门3","lang":"zh-CN","frontmatter":{"date":"2018-12-11T17:22:05.000Z","category":["图像处理"],"tag":["图像处理"],"description":"[图像处理] YUV图像处理入门3 5 yuv420格式的灰阶测试图 本程序中的函数主要是为YUV420P视频数据流的第一帧图像添加边框。函数的代码如下所示： /** * @file 5 yuv_graybar.cpp * @author luohen * @brief gray scale bar of yuv * @date 2018-12-07 * */ #include \\"stdafx.h\\" #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; #include &lt;iostream&gt; using namespace std; /** * @brief * * @param width\\t\\twidth of input yuv420p file * @param height\\theight of input yuv420p file * @param ymin\\t\\tminimum value of y * @param ymax\\t\\tmaximum value of y * @param barnum \\tNumber of bars * @param url\\t\\tlocation of input yuv420p file * @return int */ int yuv420_graybar(int width, int height, int ymin, int ymax, int barnum, const char *url) { \\t//每个灰度条的宽度 \\tint barwidth; \\t//每个灰度阶次范围 \\tfloat lum_inc; \\t//计算Y值 \\tunsigned char lum_temp; \\t//uv分量宽高 \\tint uv_width, uv_height; \\t//reading yuv image \\tFILE *input_fp; \\tif ((input_fp = fopen(url, \\"rb\\")) == NULL) \\t{ \\t\\tprintf(\\"%s open error!\\\\n\\", url); \\t\\treturn -1; \\t} \\telse \\t{ \\t\\tprintf(\\"%s open.\\\\n\\", url); \\t} \\t//writing yuv image \\tFILE *output_fp = fopen(\\"video_result/gray_test.yuv\\", \\"wb+\\"); \\tint t = 0, i = 0, j = 0; \\t//每个灰度条的宽度 \\tbarwidth = width / barnum; \\t//每个灰度阶次范围 \\tlum_inc = ((float)(ymax - ymin)) / ((float)(barnum - 1)); \\t//uv分量宽高 \\tuv_width = width / 2; \\tuv_height = height / 2; \\tunsigned char *data_y = new unsigned char[width * height]; \\tunsigned char *data_u = new unsigned char[uv_width * uv_height]; \\tunsigned char *data_v = new unsigned char[uv_width * uv_height]; \\t//Output Info \\t//输出信息 \\tprintf(\\"Y, U, V value from picture's left to right:\\\\n\\"); \\tfor (t = 0; t &lt; (width / barwidth); t++) \\t{ \\t\\t//计算Y值 \\t\\tlum_temp = ymin + (char)(t * lum_inc); \\t\\tprintf(\\"%3d, 128, 128\\\\n\\", lum_temp); \\t} \\t//保存数据 \\tfor (j = 0; j &lt; height; j++) \\t{ \\t\\tfor (i = 0; i &lt; width; i++) \\t\\t{ \\t\\t\\tt = i / barwidth; \\t\\t\\tlum_temp = ymin + (char)(t * lum_inc); \\t\\t\\tdata_y[j * width + i] = lum_temp; \\t\\t} \\t} \\tfor (j = 0; j &lt; uv_height; j++) \\t{ \\t\\tfor (i = 0; i &lt; uv_width; i++) \\t\\t{ \\t\\t\\tdata_u[j * uv_width + i] = 128; \\t\\t} \\t} \\tfor (j = 0; j &lt; uv_height; j++) \\t{ \\t\\tfor (i = 0; i &lt; uv_width; i++) \\t\\t{ \\t\\t\\tdata_v[j * uv_width + i] = 128; \\t\\t} \\t} \\tfwrite(data_y, width * height, sizeof(unsigned char), output_fp); \\tfwrite(data_u, uv_width * uv_height, sizeof(unsigned char), output_fp); \\tfwrite(data_v, uv_width * uv_height, sizeof(unsigned char), output_fp); \\tfclose(input_fp); \\tfclose(output_fp); \\tdelete[] data_y; \\tdelete[] data_u; \\tdelete[] data_v; \\treturn 0; } /** * @brief main * * @return int */ int main() { \\tint state = yuv420_graybar(640, 360, 0, 255, 10, \\"video/graybar.yuv\\"); \\treturn 0; }","head":[["meta",{"property":"og:url","content":"https://luohenyueji.github.io/blog/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/YUV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/2018-12-11-_%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%20YUV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A83.html"}],["meta",{"property":"og:site_name","content":"落痕月极的博客"}],["meta",{"property":"og:title","content":"[图像处理] YUV图像处理入门3"}],["meta",{"property":"og:description","content":"[图像处理] YUV图像处理入门3 5 yuv420格式的灰阶测试图 本程序中的函数主要是为YUV420P视频数据流的第一帧图像添加边框。函数的代码如下所示： /** * @file 5 yuv_graybar.cpp * @author luohen * @brief gray scale bar of yuv * @date 2018-12-07 * */ #include \\"stdafx.h\\" #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; #include &lt;iostream&gt; using namespace std; /** * @brief * * @param width\\t\\twidth of input yuv420p file * @param height\\theight of input yuv420p file * @param ymin\\t\\tminimum value of y * @param ymax\\t\\tmaximum value of y * @param barnum \\tNumber of bars * @param url\\t\\tlocation of input yuv420p file * @return int */ int yuv420_graybar(int width, int height, int ymin, int ymax, int barnum, const char *url) { \\t//每个灰度条的宽度 \\tint barwidth; \\t//每个灰度阶次范围 \\tfloat lum_inc; \\t//计算Y值 \\tunsigned char lum_temp; \\t//uv分量宽高 \\tint uv_width, uv_height; \\t//reading yuv image \\tFILE *input_fp; \\tif ((input_fp = fopen(url, \\"rb\\")) == NULL) \\t{ \\t\\tprintf(\\"%s open error!\\\\n\\", url); \\t\\treturn -1; \\t} \\telse \\t{ \\t\\tprintf(\\"%s open.\\\\n\\", url); \\t} \\t//writing yuv image \\tFILE *output_fp = fopen(\\"video_result/gray_test.yuv\\", \\"wb+\\"); \\tint t = 0, i = 0, j = 0; \\t//每个灰度条的宽度 \\tbarwidth = width / barnum; \\t//每个灰度阶次范围 \\tlum_inc = ((float)(ymax - ymin)) / ((float)(barnum - 1)); \\t//uv分量宽高 \\tuv_width = width / 2; \\tuv_height = height / 2; \\tunsigned char *data_y = new unsigned char[width * height]; \\tunsigned char *data_u = new unsigned char[uv_width * uv_height]; \\tunsigned char *data_v = new unsigned char[uv_width * uv_height]; \\t//Output Info \\t//输出信息 \\tprintf(\\"Y, U, V value from picture's left to right:\\\\n\\"); \\tfor (t = 0; t &lt; (width / barwidth); t++) \\t{ \\t\\t//计算Y值 \\t\\tlum_temp = ymin + (char)(t * lum_inc); \\t\\tprintf(\\"%3d, 128, 128\\\\n\\", lum_temp); \\t} \\t//保存数据 \\tfor (j = 0; j &lt; height; j++) \\t{ \\t\\tfor (i = 0; i &lt; width; i++) \\t\\t{ \\t\\t\\tt = i / barwidth; \\t\\t\\tlum_temp = ymin + (char)(t * lum_inc); \\t\\t\\tdata_y[j * width + i] = lum_temp; \\t\\t} \\t} \\tfor (j = 0; j &lt; uv_height; j++) \\t{ \\t\\tfor (i = 0; i &lt; uv_width; i++) \\t\\t{ \\t\\t\\tdata_u[j * uv_width + i] = 128; \\t\\t} \\t} \\tfor (j = 0; j &lt; uv_height; j++) \\t{ \\t\\tfor (i = 0; i &lt; uv_width; i++) \\t\\t{ \\t\\t\\tdata_v[j * uv_width + i] = 128; \\t\\t} \\t} \\tfwrite(data_y, width * height, sizeof(unsigned char), output_fp); \\tfwrite(data_u, uv_width * uv_height, sizeof(unsigned char), output_fp); \\tfwrite(data_v, uv_width * uv_height, sizeof(unsigned char), output_fp); \\tfclose(input_fp); \\tfclose(output_fp); \\tdelete[] data_y; \\tdelete[] data_u; \\tdelete[] data_v; \\treturn 0; } /** * @brief main * * @return int */ int main() { \\tint state = yuv420_graybar(640, 360, 0, 255, 10, \\"video/graybar.yuv\\"); \\treturn 0; }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"落痕月极"}],["meta",{"property":"article:tag","content":"图像处理"}],["meta",{"property":"article:published_time","content":"2018-12-11T17:22:05.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"[图像处理] YUV图像处理入门3\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-12-11T17:22:05.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"落痕月极\\",\\"url\\":\\"/\\"}]}"]]},"headers":[{"level":2,"title":"5 yuv420格式的灰阶测试图","slug":"_5-yuv420格式的灰阶测试图","link":"#_5-yuv420格式的灰阶测试图","children":[]},{"level":2,"title":"6 两张yuv420p图像的峰值信噪比（psnr）计算","slug":"_6-两张yuv420p图像的峰值信噪比-psnr-计算","link":"#_6-两张yuv420p图像的峰值信噪比-psnr-计算","children":[]},{"level":2,"title":"7 yuv420图像顺时针旋转90度","slug":"_7-yuv420图像顺时针旋转90度","link":"#_7-yuv420图像顺时针旋转90度","children":[]},{"level":2,"title":"8 yuv420图像大小重置","slug":"_8-yuv420图像大小重置","link":"#_8-yuv420图像大小重置","children":[]}],"git":{},"readingTime":{"minutes":7.72,"words":2317},"filePathRelative":"blog/图像处理/YUV图像处理入门/2018-12-11-[图像处理] YUV图像处理入门3.md","localizedDate":"2018年12月12日","excerpt":"<h1> [图像处理] YUV图像处理入门3</h1>\\n<h2> 5 yuv420格式的灰阶测试图</h2>\\n<p>本程序中的函数主要是为YUV420P视频数据流的第一帧图像添加边框。函数的代码如下所示：\\n/**\\n* @file 5 yuv_graybar.cpp\\n* @author luohen\\n* @brief gray scale bar of yuv\\n* @date 2018-12-07\\n*\\n*/</p>\\n<pre><code>#include \\"stdafx.h\\"\\n#include &lt;stdio.h&gt;\\n#include &lt;stdlib.h&gt;\\n#include &lt;string.h&gt;\\n#include &lt;math.h&gt;\\n#include &lt;iostream&gt;\\n\\nusing namespace std;\\n\\n/**\\n * @brief\\n *\\n * @param width\\t\\twidth of input yuv420p file\\n * @param height\\theight of input yuv420p file\\n * @param ymin\\t\\tminimum value of y\\n * @param ymax\\t\\tmaximum value of y\\n * @param barnum \\tNumber of bars\\n * @param url\\t\\tlocation of input yuv420p file\\n * @return int\\n */\\nint yuv420_graybar(int width, int height, int ymin, int ymax, int barnum, const char *url)\\n{\\n\\t//每个灰度条的宽度\\n\\tint barwidth;\\n\\t//每个灰度阶次范围\\n\\tfloat lum_inc;\\n\\t//计算Y值\\n\\tunsigned char lum_temp;\\n\\t//uv分量宽高\\n\\tint uv_width, uv_height;\\n\\t//reading yuv image\\n\\tFILE *input_fp;\\n\\tif ((input_fp = fopen(url, \\"rb\\")) == NULL)\\n\\t{\\n\\t\\tprintf(\\"%s open error!\\\\n\\", url);\\n\\t\\treturn -1;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tprintf(\\"%s open.\\\\n\\", url);\\n\\t}\\n\\t//writing yuv image\\n\\tFILE *output_fp = fopen(\\"video_result/gray_test.yuv\\", \\"wb+\\");\\n\\n\\tint t = 0, i = 0, j = 0;\\n\\n\\t//每个灰度条的宽度\\n\\tbarwidth = width / barnum;\\n\\t//每个灰度阶次范围\\n\\tlum_inc = ((float)(ymax - ymin)) / ((float)(barnum - 1));\\n\\t//uv分量宽高\\n\\tuv_width = width / 2;\\n\\tuv_height = height / 2;\\n\\n\\tunsigned char *data_y = new unsigned char[width * height];\\n\\tunsigned char *data_u = new unsigned char[uv_width * uv_height];\\n\\tunsigned char *data_v = new unsigned char[uv_width * uv_height];\\n\\n\\t//Output Info\\n\\t//输出信息\\n\\tprintf(\\"Y, U, V value from picture's left to right:\\\\n\\");\\n\\tfor (t = 0; t &lt; (width / barwidth); t++)\\n\\t{\\n\\t\\t//计算Y值\\n\\t\\tlum_temp = ymin + (char)(t * lum_inc);\\n\\t\\tprintf(\\"%3d, 128, 128\\\\n\\", lum_temp);\\n\\t}\\n\\t//保存数据\\n\\tfor (j = 0; j &lt; height; j++)\\n\\t{\\n\\t\\tfor (i = 0; i &lt; width; i++)\\n\\t\\t{\\n\\t\\t\\tt = i / barwidth;\\n\\t\\t\\tlum_temp = ymin + (char)(t * lum_inc);\\n\\t\\t\\tdata_y[j * width + i] = lum_temp;\\n\\t\\t}\\n\\t}\\n\\tfor (j = 0; j &lt; uv_height; j++)\\n\\t{\\n\\t\\tfor (i = 0; i &lt; uv_width; i++)\\n\\t\\t{\\n\\t\\t\\tdata_u[j * uv_width + i] = 128;\\n\\t\\t}\\n\\t}\\n\\tfor (j = 0; j &lt; uv_height; j++)\\n\\t{\\n\\t\\tfor (i = 0; i &lt; uv_width; i++)\\n\\t\\t{\\n\\t\\t\\tdata_v[j * uv_width + i] = 128;\\n\\t\\t}\\n\\t}\\n\\n\\tfwrite(data_y, width * height, sizeof(unsigned char), output_fp);\\n\\tfwrite(data_u, uv_width * uv_height, sizeof(unsigned char), output_fp);\\n\\tfwrite(data_v, uv_width * uv_height, sizeof(unsigned char), output_fp);\\n\\tfclose(input_fp);\\n\\tfclose(output_fp);\\n\\n\\tdelete[] data_y;\\n\\tdelete[] data_u;\\n\\tdelete[] data_v;\\n\\treturn 0;\\n}\\n\\n/**\\n * @brief main\\n *\\n * @return int\\n */\\nint main()\\n{\\n\\tint state = yuv420_graybar(640, 360, 0, 255, 10, \\"video/graybar.yuv\\");\\n\\treturn 0;\\n}\\n</code></pre>","autoDesc":true}`);export{t as data};
