import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as o,o as i,c as p,a as n,d as e,b as s,e as l}from"./app-MsA2k2kn.js";const c={},r=n("h1",{id:"机器学习-yellowbrick使用笔记8-模型选择可视化",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#机器学习-yellowbrick使用笔记8-模型选择可视化","aria-hidden":"true"},"#"),s(" [机器学习] Yellowbrick使用笔记8-模型选择可视化")],-1),u=n("p",null,"Yellowbrick可视化工具旨在指导模型选择过程。一般来说，模型选择是一个搜索问题，定义如下：给定N个由数值属性描述的实例和（可选）一个估计目标，找到一个由特征、算法和最适合数据的超参数组成的三元组描述的模型。在大多数情况下，“最佳”三元组是指收到模型类型的最佳交叉验证分数的三元组。",-1),d={href:"https://github.com/luohenyueji/Python-Study-Notes/tree/master/Documents/Yellowbrick%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0",target:"_blank",rel:"noopener noreferrer"},k=n("strong",null,"代码下载",-1),m=n("p",null,"Yellowbrick.model_select包提供了可视化工具，用于检查交叉验证和超参数调优的性能。 许多可视化工具包装sklearn.model_select和其他工具中的功能，用于执行多模型比较。",-1),v=n("p",null,"当前实现的模型选择可视化器如下：",-1),b=n("ul",null,[n("li",null,"验证曲线：可视化超参数的调整如何影响训练和测试分数，以调整偏差/方差。"),n("li",null,"学习曲线：显示训练数据的大小如何影响模型，以诊断模型是否受方差误差和偏差误差的影响更大。"),n("li",null,"交叉验证分数：将交叉验证的分数显示为条形图，平均值作为水平线。"),n("li",null,"特征重要性：按模型中的相对重要性对特征进行排名"),n("li",null,"递归特征消除：按重要性选择特征子集")],-1),h=n("p",null,"模型选择大量使用交叉验证来评估估计器的性能。交叉验证将数据集分为训练数据集和测试数据集；该模型适合训练数据，并根据测试数据进行评估。这有助于避免常见的陷阱，过度拟合，因为模型只会记住训练数据，而不能很好地推广到新的或未知的输入中。",-1),g={href:"http://scikit-learn.org/stable/modules/cross_validation.html",target:"_blank",rel:"noopener noreferrer"},_=l(`<p>本文如果数据集下载不下来，查看下面地址，然后放入yellowbrick安装目录\\datasets\\fixtures文件夹:</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>{
  &quot;bikeshare&quot;: {
    &quot;url&quot;: &quot;https://s3.amazonaws.com/ddl-data-lake/yellowbrick/v1.0/bikeshare.zip&quot;,
    &quot;signature&quot;: &quot;4ed07a929ccbe0171309129e6adda1c4390190385dd6001ba9eecc795a21eef2&quot;
  },
  &quot;hobbies&quot;: {
    &quot;url&quot;: &quot;https://s3.amazonaws.com/ddl-data-lake/yellowbrick/v1.0/hobbies.zip&quot;,
    &quot;signature&quot;: &quot;6114e32f46baddf049a18fb05bad3efa98f4e6a0fe87066c94071541cb1e906f&quot;
  },
  &quot;concrete&quot;: {
    &quot;url&quot;: &quot;https://s3.amazonaws.com/ddl-data-lake/yellowbrick/v1.0/concrete.zip&quot;,
    &quot;signature&quot;: &quot;5807af2f04e14e407f61e66a4f3daf910361a99bb5052809096b47d3cccdfc0a&quot;
  },
  &quot;credit&quot;: {
    &quot;url&quot;: &quot;https://s3.amazonaws.com/ddl-data-lake/yellowbrick/v1.0/credit.zip&quot;,
    &quot;signature&quot;: &quot;2c6f5821c4039d70e901cc079d1404f6f49c3d6815871231c40348a69ae26573&quot;
  },
  &quot;energy&quot;: {
    &quot;url&quot;: &quot;https://s3.amazonaws.com/ddl-data-lake/yellowbrick/v1.0/energy.zip&quot;,
    &quot;signature&quot;: &quot;174eca3cd81e888fc416c006de77dbe5f89d643b20319902a0362e2f1972a34e&quot;
  },
  &quot;game&quot;: {
    &quot;url&quot;: &quot;https://s3.amazonaws.com/ddl-data-lake/yellowbrick/v1.0/game.zip&quot;,
    &quot;signature&quot;: &quot;ce799d1c55fcf1985a02def4d85672ac86c022f8f7afefbe42b20364fba47d7a&quot;
  },
  &quot;mushroom&quot;: {
    &quot;url&quot;: &quot;https://s3.amazonaws.com/ddl-data-lake/yellowbrick/v1.0/mushroom.zip&quot;,
    &quot;signature&quot;: &quot;f79fdbc33b012dabd06a8f3cb3007d244b6aab22d41358b9aeda74417c91f300&quot;
  },
  &quot;occupancy&quot;: {
    &quot;url&quot;: &quot;https://s3.amazonaws.com/ddl-data-lake/yellowbrick/v1.0/occupancy.zip&quot;,
    &quot;signature&quot;: &quot;0b390387584586a05f45c7da610fdaaf8922c5954834f323ae349137394e6253&quot;
  },
  &quot;spam&quot;: {
    &quot;url&quot;: &quot;https://s3.amazonaws.com/ddl-data-lake/yellowbrick/v1.0/spam.zip&quot;,
    &quot;signature&quot;: &quot;000309ac2b61090a3001de3e262a5f5319708bb42791c62d15a08a2f9f7cb30a&quot;
  },
  &quot;walking&quot;: {
    &quot;url&quot;: &quot;https://s3.amazonaws.com/ddl-data-lake/yellowbrick/v1.0/walking.zip&quot;,
    &quot;signature&quot;: &quot;7a36615978bc3bb74a2e9d5de216815621bd37f6a42c65d3fc28b242b4d6e040&quot;
  },
  &quot;nfl&quot;: {
    &quot;url&quot;: &quot;https://s3.amazonaws.com/ddl-data-lake/yellowbrick/v1.0/nfl.zip&quot;,
    &quot;signature&quot;: &quot;4989c66818ea18217ee0fe3a59932b963bd65869928c14075a5c50366cb81e1f&quot;
  }
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>[toc]</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> warnings
warnings<span class="token punctuation">.</span>filterwarnings<span class="token punctuation">(</span><span class="token string">&quot;ignore&quot;</span><span class="token punctuation">)</span>

<span class="token comment"># 多行输出</span>
<span class="token keyword">from</span> IPython<span class="token punctuation">.</span>core<span class="token punctuation">.</span>interactiveshell <span class="token keyword">import</span> InteractiveShell
InteractiveShell<span class="token punctuation">.</span>ast_node_interactivity <span class="token operator">=</span> <span class="token string">&quot;all&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="_1-验证曲线" tabindex="-1"><a class="header-anchor" href="#_1-验证曲线" aria-hidden="true">#</a> 1 验证曲线</h2><p>模型验证用于确定估计器对经过训练的数据的有效性以及对新输入的通用性。为了衡量模型的性能，我们首先将数据集分为训练和测试分割，将模型拟合到训练数据上并在保留的测试数据上评分。</p><p>为了使评分最大化，必须选择模型的超参数，使模型在指定的特征空间内运行。大多数模型都有多个超参数，选择这些参数组合的最佳方法是使用网格搜索。然而，有时绘制单个超参数对训练和测试数据的影响，以确定估计器对某些超参数值是欠拟合还是过拟合是有用的。</p><table><thead><tr><th>可视化器</th><th>ValidationCurve</th></tr></thead><tbody><tr><td>快速使用方法</td><td>validation_curve()</td></tr><tr><td>模型</td><td>分类与回归</td></tr><tr><td>工作流程</td><td>选型</td></tr></tbody></table><h3 id="_1-1-基础使用" tabindex="-1"><a class="header-anchor" href="#_1-1-基础使用" aria-hidden="true">#</a> 1.1 基础使用</h3><p>在第一个示例中，我们将使用ValidationCurve可视化工具探索回归数据集，在第二个示例中探索分类数据集。请注意，任何实现fit()且predict()具有适当评分机制的估算器均可与此可视化工具一起使用。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_energy
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> ValidationCurve

<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>tree <span class="token keyword">import</span> DecisionTreeRegressor

<span class="token comment"># Load a regression dataset</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_energy<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># param_name参数名称</span>
<span class="token comment"># param_range参数范围</span>
<span class="token comment"># cv交叉认证指定折数</span>
<span class="token comment"># scoring评价指标</span>
viz <span class="token operator">=</span> ValidationCurve<span class="token punctuation">(</span>
    DecisionTreeRegressor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> param_name<span class="token operator">=</span><span class="token string">&quot;max_depth&quot;</span><span class="token punctuation">,</span>
    param_range<span class="token operator">=</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">&quot;r2&quot;</span>
<span class="token punctuation">)</span>

<span class="token comment"># Fit and show the visualizer</span>
viz<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
viz<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>&lt;Figure size 800x550 with 1 Axes&gt;
</code></pre><p>在加载和修改数据之后，我们使用一个DecisionTreeRegressor初始化ValidationCurve。决策树越深越过适合，因为在树的每一层，分区处理的数据子集越小。处理这种过拟合过程的一种方法是限制树的深度。验证曲线探索了“max_depth”参数与R2评分之间的关系，并进行了10个shuffle拆分交叉验证。参数param_range指定max_depth的值，这里从1到10不等。</p><p>从可视化结果中我们可以看到，深度限制小于5个水平严重不适合这个数据集上的模型，因为训练分数和测试分数在这个参数范围内一起攀升，并且由于测试分数交叉验证的高可变性。深度为7之后，训练和测试的分数就会出现分歧，这是因为更深的树开始过度拟合训练数据，无法为模型提供普遍性。然而，由于交叉验证的分数不一定会减少，所以模型不会因为方差而产生很大的误差。</p><h3 id="_1-2-快速方法" tabindex="-1"><a class="header-anchor" href="#_1-2-快速方法" aria-hidden="true">#</a> 1.2 快速方法</h3><p>使用关联的快速方法，可以在一行中实现与上述类似的功能validation_curve。此方法将实例化并适合ValidationCurve可视化器。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_energy
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> validation_curve

<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>tree <span class="token keyword">import</span> DecisionTreeRegressor

<span class="token comment"># Load a regression dataset</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_energy<span class="token punctuation">(</span><span class="token punctuation">)</span>

viz <span class="token operator">=</span> validation_curve<span class="token punctuation">(</span>
    DecisionTreeRegressor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> param_name<span class="token operator">=</span><span class="token string">&quot;max_depth&quot;</span><span class="token punctuation">,</span>
    param_range<span class="token operator">=</span>np<span class="token punctuation">.</span>arange<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">&quot;r2&quot;</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_7_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><h2 id="_2-学习曲线" tabindex="-1"><a class="header-anchor" href="#_2-学习曲线" aria-hidden="true">#</a> 2 学习曲线</h2><p>学习曲线显示了针对具有不同数量训练样本的估计量，训练分数与交叉验证的测试分数之间的关系。该可视化通常用于显示两件事：</p><p>估算器可从更多数据中受益多少（例如，我们是否有“足够的数据”，或者如果以在线方式使用，估算器会变得更好）。</p><p>如果估算器对因方差引起的误差与因偏差引起的误差更敏感。</p><table><thead><tr><th>可视化器</th><th>LearningCurve</th></tr></thead><tbody><tr><td>快速使用方法</td><td>learning_curve()</td></tr><tr><td>模型</td><td>分类，回归，聚类</td></tr><tr><td>工作流程</td><td>选型</td></tr></tbody></table><p>如果训练和交叉验证的分数随着更多数据的增加而聚合在一起（如左图所示），那么模型可能不会从更多的数据中获益。如果训练得分远大于验证得分，那么模型可能需要更多的训练实例，以便更有效地推广。 曲线用平均得分绘制，但是交叉验证过程中的可变性用阴影区域表示，所有交叉验证的平均值上下都有一个标准偏差。如果模型由于偏差而出现误差，那么在训练分数曲线附近可能会有更多的变化。如果模型由于方差而出现误差，那么在交叉验证得分附近会有更多的可变性。</p><h3 id="_2-1-分类" tabindex="-1"><a class="header-anchor" href="#_2-1-分类" aria-hidden="true">#</a> 2.1 分类</h3><p>在下面的示例中，我们将展示如何可视化分类模型的学习曲线。 在加载DataFrame并执行分类编码之后，我们创建了一个StratifiedKFold交叉验证策略，以确保每个拆分中的所有类都以相同的比例表示。 然后，我们使用F1_加权评分度量(而不是默认度量准确度)来拟合可视化工具，以更好地了解分类器中的精确度和召回率之间的关系。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np

<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> StratifiedKFold
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>naive_bayes <span class="token keyword">import</span> MultinomialNB
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>preprocessing <span class="token keyword">import</span> OneHotEncoder<span class="token punctuation">,</span> LabelEncoder

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_game
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> LearningCurve

<span class="token comment"># Load a classification dataset</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_game<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># Encode the categorical data</span>
X <span class="token operator">=</span> OneHotEncoder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>X<span class="token punctuation">)</span>
y <span class="token operator">=</span> LabelEncoder<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>fit_transform<span class="token punctuation">(</span>y<span class="token punctuation">)</span>

<span class="token comment"># Create the learning curve visualizer</span>
cv <span class="token operator">=</span> StratifiedKFold<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">)</span>
sizes <span class="token operator">=</span> np<span class="token punctuation">.</span>linspace<span class="token punctuation">(</span><span class="token number">0.3</span><span class="token punctuation">,</span> <span class="token number">1.0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span>

<span class="token comment"># Instantiate the classification model and visualizer</span>
model <span class="token operator">=</span> MultinomialNB<span class="token punctuation">(</span><span class="token punctuation">)</span>
visualizer <span class="token operator">=</span> LearningCurve<span class="token punctuation">(</span>
    model<span class="token punctuation">,</span> cv<span class="token operator">=</span>cv<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">&#39;f1_weighted&#39;</span><span class="token punctuation">,</span> train_sizes<span class="token operator">=</span>sizes<span class="token punctuation">,</span> n_jobs<span class="token operator">=</span><span class="token number">4</span>
<span class="token punctuation">)</span>

visualizer<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>        <span class="token comment"># Fit the data to the visualizer</span>
visualizer<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_10_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><p>这条学习曲线显示了高测试可变性和低分数，高达30000个实例，然而在这个水平之后，模型开始收敛到F1分数0.6左右。我们可以看到训练和测试的分数还没有收敛，所以这个模型可能会从更多的训练数据中获益。最后，该模型主要受方差误差的影响（测试数据的CV分数比训练数据的变异性更大），因此模型有可能过度拟合。</p><h3 id="_2-2-回归" tabindex="-1"><a class="header-anchor" href="#_2-2-回归" aria-hidden="true">#</a> 2.2 回归</h3><p>为回归建立学习曲线非常简单，而且非常相似。在下面的示例中，在加载数据并选择目标之后，我们根据确定系数或R2分数探索学习曲线分数。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> RidgeCV

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_energy
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> LearningCurve

<span class="token comment"># Load a regression dataset</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_energy<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># Instantiate the regression model and visualizer</span>
model <span class="token operator">=</span> RidgeCV<span class="token punctuation">(</span><span class="token punctuation">)</span>
visualizer <span class="token operator">=</span> LearningCurve<span class="token punctuation">(</span>model<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">&#39;r2&#39;</span><span class="token punctuation">)</span>

visualizer<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>        <span class="token comment"># Fit the data to the visualizer</span>
visualizer<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment"># Finalize and render the figure</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_13_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><p>该学习曲线显示出非常高的可变性，并且得分较低，直到大约350个实例为止。显然，该模型可以从更多数据中受益，因为它的得分很高。潜在地，随着更多的数据和更大的正则化alpha值，该模型在测试数据中的可变性将大大降低</p><h3 id="_2-3-聚类" tabindex="-1"><a class="header-anchor" href="#_2-3-聚类" aria-hidden="true">#</a> 2.3 聚类</h3><p>学习曲线也适用于聚类模型，并且可以使用指定聚类的形状或组织的度量，例如轮廓分数或密度分数。如果预先知道membership，则可以使用rand得分来比较聚类性能，如下所示：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>cluster <span class="token keyword">import</span> KMeans
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> make_blobs

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> LearningCurve

<span class="token comment"># Generate synthetic dataset with 5 random clusters</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> make_blobs<span class="token punctuation">(</span>n_samples<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">,</span> centers<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span>

<span class="token comment"># Instantiate the clustering model and visualizer</span>
model <span class="token operator">=</span> KMeans<span class="token punctuation">(</span><span class="token punctuation">)</span>
visualizer <span class="token operator">=</span> LearningCurve<span class="token punctuation">(</span>model<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">&quot;adjusted_rand_score&quot;</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span>

visualizer<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>        <span class="token comment"># Fit the data to the visualizer</span>
visualizer<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment"># Finalize and render the figure</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_16_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><p>不幸的是，对于随机数据，这些曲线变化很大，但是可以指出一些特定于聚类的项。首先，请注意y轴很窄，粗略地说，这些曲线是收敛的，并且实际上聚类算法的表现非常好。其次，对于集群而言，数据点的收敛不一定是一件坏事；实际上，我们希望确保在添加更多数据时，训练和交叉验证分数不会出现差异。</p><h3 id="_2-4-快速方法" tabindex="-1"><a class="header-anchor" href="#_2-4-快速方法" aria-hidden="true">#</a> 2.4 快速方法</h3><p>使用关联的快速方法可以实现相同的功能learning_curve。此方法将LearningCurve使用关联的参数构建对象，将其拟合，然后（可选）立即显示可视化效果。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> RidgeCV

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_energy
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> learning_curve

<span class="token comment"># Load a regression dataset</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_energy<span class="token punctuation">(</span><span class="token punctuation">)</span>

learning_curve<span class="token punctuation">(</span>RidgeCV<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">&#39;r2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_19_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><h2 id="_3-交叉验证分数" tabindex="-1"><a class="header-anchor" href="#_3-交叉验证分数" aria-hidden="true">#</a> 3 交叉验证分数</h2><p>通常，我们通过查看给定模型的F1，精度，召回率和准确性（用于分类），或者确定系数（R2）和误差（用于回归）来确定其是否最优。但是，现实世界中的数据通常分布不均，这意味着拟合模型在数据的某些部分上的表现可能要好于其他部分。Yellowbrick的CVScores可视化工具使我们能够使用不同的交叉验证策略直观地探索这些性能差异。</p><table><thead><tr><th>可视化器</th><th>CVScores</th></tr></thead><tbody><tr><td>快速使用方法</td><td>cv_scores()</td></tr><tr><td>模型</td><td>分类，回归</td></tr><tr><td>工作流程</td><td>选型</td></tr></tbody></table><h3 id="_3-1-交叉验证介绍" tabindex="-1"><a class="header-anchor" href="#_3-1-交叉验证介绍" aria-hidden="true">#</a> 3.1 交叉验证介绍</h3><p>交叉验证首先对数据进行无序处理（以防止意外的排序错误）并将其拆分为k个折叠。然后k模型适用于k-1/k的数据（称为训练分割），并对1/k的数据进行评估（称为测试分割）。每个评估的结果被平均在一起作为最终得分，然后最终模型适合于整个数据集进行操作。</p><p>在Yellowbrick中，CVScores可视化工具将交叉验证的分数显示为条形图（每折一个条形），所有折的平均分数绘制为水平虚线。</p><figure><img src="https://www.scikit-yb.org/en/latest/_images/cross_validation.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="_3-2-分类" tabindex="-1"><a class="header-anchor" href="#_3-2-分类" aria-hidden="true">#</a> 3.2 分类</h3><p>在下面的示例中，我们显示了如何可视化分类模型的交叉验证得分。将占用数据加载为之后DataFrame，我们创建了StratifiedKFold交叉验证策略，以确保每个分组中的所有类均以相同的比例表示。然后，我们CVScores使用f1_weighted评分指标而不是默认指标“准确度”来拟合展示台，以便更好地了解分类器中所有折的精确度和召回率之间的关系。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> StratifiedKFold
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>naive_bayes <span class="token keyword">import</span> MultinomialNB

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_occupancy
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> CVScores

<span class="token comment"># Load the classification dataset</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_occupancy<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># Create a cross-validation strategy</span>
<span class="token comment"># 浇查验证策略</span>
cv <span class="token operator">=</span> StratifiedKFold<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span>

<span class="token comment"># Instantiate the classification model and visualizer</span>
model <span class="token operator">=</span> MultinomialNB<span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment"># 交叉验证获得分数</span>
visualizer <span class="token operator">=</span> CVScores<span class="token punctuation">(</span>model<span class="token punctuation">,</span> cv<span class="token operator">=</span>cv<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">&#39;f1_weighted&#39;</span><span class="token punctuation">)</span>

visualizer<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>        <span class="token comment"># Fit the data to the visualizer</span>
visualizer<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment"># Finalize and render the figure</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_23_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><p>我们得到的可视化结果表明，尽管我们的平均交叉验证得分非常高，但是在某些拆分中，我们的拟合MultinomialNB分类器的效果明显较差。</p><h3 id="_3-3-回归" tabindex="-1"><a class="header-anchor" href="#_3-3-回归" aria-hidden="true">#</a> 3.3 回归</h3><p>在下一个示例中，我们显示如何可视化回归模型的交叉验证得分。在以加载enerygy数据，我们实例化了一个简单的KFold交叉验证策略。然后，我们通过CVScores使用r2计分指标对展示台进行拟合，以了解所有折处回归器的确定系数。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> Ridge
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> KFold

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_energy
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> CVScores

<span class="token comment"># Load the regression dataset</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_energy<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># Instantiate the regression model and visualizer</span>
cv <span class="token operator">=</span> KFold<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span>

model <span class="token operator">=</span> Ridge<span class="token punctuation">(</span><span class="token punctuation">)</span>
visualizer <span class="token operator">=</span> CVScores<span class="token punctuation">(</span>model<span class="token punctuation">,</span> cv<span class="token operator">=</span>cv<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">&#39;r2&#39;</span><span class="token punctuation">)</span>

visualizer<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>        <span class="token comment"># Fit the data to the visualizer</span>
visualizer<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment"># Finalize and render the figure</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_26_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><p>与我们的分类CVScores可视化一样，我们的回归可视化表明我们的Ridge回归器几乎在所有折中都表现非常出色（例如，产生较高的确定系数），从而导致总体R2得分更高。</p><h3 id="_3-4-快速方法" tabindex="-1"><a class="header-anchor" href="#_3-4-快速方法" aria-hidden="true">#</a> 3.4 快速方法</h3><p>上面的相同功能可以通过关联的快速方法来实现cv_scores。此方法将CVScores使用关联的参数构建对象，将其拟合，然后（可选）立即显示可视化效果。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> Ridge
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> KFold

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_energy
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> cv_scores

<span class="token comment"># Load the regression dataset</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_energy<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># Instantiate the regression model and visualizer</span>
cv <span class="token operator">=</span> KFold<span class="token punctuation">(</span>n_splits<span class="token operator">=</span><span class="token number">12</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">42</span><span class="token punctuation">)</span>

model <span class="token operator">=</span> Ridge<span class="token punctuation">(</span><span class="token punctuation">)</span>
visualizer <span class="token operator">=</span> cv_scores<span class="token punctuation">(</span>model<span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">,</span> cv<span class="token operator">=</span>cv<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">&#39;r2&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_29_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><h2 id="_4-特征重要性" tabindex="-1"><a class="header-anchor" href="#_4-特征重要性" aria-hidden="true">#</a> 4 特征重要性</h2><p>特征工程过程包括选择所需的最小特征来生成一个有效的模型，因为模型包含的特征越多，它就越复杂（数据越稀疏），因此模型对方差引起的误差就越敏感。消除特征的一种常见方法是描述它们对模型的相对重要性，然后消除薄弱的特征或特征的组合，然后重新评估，以确定在交叉验证期间模型是否更好。</p><p>许多模型形式描述了要素相对于彼此的潜在影响。在scikit-learn中，决策树模型和树的集合（例如，Random Forest，Gradient Boosting和Ada Boost）会feature_importances_在拟合时提供 属性。Yellowbrick FeatureImportances可视化工具利用此属性对相对重要性进行排名和绘图。</p><table><thead><tr><th>可视化器</th><th>FeatureImportances</th></tr></thead><tbody><tr><td>快速使用方法</td><td>feature_importances()</td></tr><tr><td>模型</td><td>分类，回归</td></tr><tr><td>工作流程</td><td>选型,特征提取</td></tr></tbody></table><h3 id="_4-1-基本使用" tabindex="-1"><a class="header-anchor" href="#_4-1-基本使用" aria-hidden="true">#</a> 4.1 基本使用</h3><p>让我们从一个例子开始；首先加载分类数据集。</p><p>然后，我们可以创建一个新图形（这是可选的，如果Axes未指定，Yellowbrick将使用当前图形或创建一个图形）。然后，我们可以为FeatureImportances展示台添加，GradientBoostingClassifier以可视化排名特征。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>ensemble <span class="token keyword">import</span> RandomForestClassifier

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_occupancy
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> FeatureImportances

<span class="token comment"># Load the classification data set</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_occupancy<span class="token punctuation">(</span><span class="token punctuation">)</span>

model <span class="token operator">=</span> RandomForestClassifier<span class="token punctuation">(</span>n_estimators<span class="token operator">=</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token comment"># 显示特征对于分类的重要程度</span>
viz <span class="token operator">=</span> FeatureImportances<span class="token punctuation">(</span>model<span class="token punctuation">)</span>
viz<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
viz<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_32_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><p>相对于其相对重要性（即最重要特征的重要性百分比）绘制特征。可视化器还包含features_和 feature_importances_属性以获取排名的数值。</p><p>对于不支持feature_importances_属性的 模型，FeatureImportances可视化工具还将为coef_ 许多线性模型提供的属性绘制条形图。但是要注意的是系数重要性的解释取决于模型。</p><p>使用带有coef_属性的模型时，最好设置 relative=False为绘制系数的真实大小（可能为负）。如果数据集没有列名或打印更好的标题，我们也可以指定我们自己的标签集。在下面的示例中，我们为案例加了标题以提高可读性：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> Lasso
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_concrete
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> FeatureImportances

<span class="token comment"># Load the regression dataset</span>
dataset <span class="token operator">=</span> load_concrete<span class="token punctuation">(</span>return_dataset<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">)</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> dataset<span class="token punctuation">.</span>to_data<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># Title case the feature for better display and create the visualizer</span>
labels <span class="token operator">=</span> <span class="token builtin">list</span><span class="token punctuation">(</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> s<span class="token punctuation">:</span> s<span class="token punctuation">.</span>title<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dataset<span class="token punctuation">.</span>meta<span class="token punctuation">[</span><span class="token string">&#39;features&#39;</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
viz <span class="token operator">=</span> FeatureImportances<span class="token punctuation">(</span>Lasso<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token operator">=</span>labels<span class="token punctuation">,</span> relative<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>

<span class="token comment"># Fit and show the feature importances</span>
viz<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
viz<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_34_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><h3 id="_4-2-堆叠重要性特征" tabindex="-1"><a class="header-anchor" href="#_4-2-堆叠重要性特征" aria-hidden="true">#</a> 4.2 堆叠重要性特征</h3><p>有些估计器返回一个多维数组，用于feature_importances_x或coef_u属性。例如，在多类情况下，LogisticRegression分类器返回一个coef_u数组，其形状为（n_classes，n_features）。这些系数将特征的重要性映射到特定类别的概率预测中。虽然多维特征重要性的解释依赖于特定的估计器和模型族，但是在FeatureImportances visualizer中对数据的处理是相同的，即重要性被平均化。</p><p>出于几个原因，采用重要性的平均值可能是不可取的。例如，某个特性对于某些类来说可能比其他类更具信息量。在本质上是多个内部模型的情况下，多输出估计量也不会从中受益。在这种情况下，使用stack=True参数绘制重要程度的堆积条形图，如下所示：</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> FeatureImportances
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>linear_model <span class="token keyword">import</span> LogisticRegression
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_iris

data <span class="token operator">=</span> load_iris<span class="token punctuation">(</span><span class="token punctuation">)</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> data<span class="token punctuation">.</span>data<span class="token punctuation">,</span> data<span class="token punctuation">.</span>target

model <span class="token operator">=</span> LogisticRegression<span class="token punctuation">(</span>multi_class<span class="token operator">=</span><span class="token string">&quot;auto&quot;</span><span class="token punctuation">,</span> solver<span class="token operator">=</span><span class="token string">&quot;liblinear&quot;</span><span class="token punctuation">)</span>
viz <span class="token operator">=</span> FeatureImportances<span class="token punctuation">(</span>model<span class="token punctuation">,</span> stack<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> relative<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span>
viz<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
viz<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_36_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><h3 id="_4-3-快速方法" tabindex="-1"><a class="header-anchor" href="#_4-3-快速方法" aria-hidden="true">#</a> 4.3 快速方法</h3><p>可以通过关联的快速方法feature_importances实现上述相同功能。此方法将FeatureImportances使用关联的参数构建对象，将其拟合，然后 from sklearn.ensemble import AdaBoostClassifier（可选）立即显示它。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>ensemble <span class="token keyword">import</span> AdaBoostClassifier
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_occupancy
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> feature_importances

<span class="token comment"># Load dataset</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_occupancy<span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment"># Use the quick method and immediately show the figure</span>
feature_importances<span class="token punctuation">(</span>AdaBoostClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> X<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_38_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><h2 id="_5-递归特征消除" tabindex="-1"><a class="header-anchor" href="#_5-递归特征消除" aria-hidden="true">#</a> 5 递归特征消除</h2><p>递归特征消除（RFE）是一种特征选择方法，它适合模型并删除最弱的一个或多个特征，直到达到指定数量的特征为止。特征按模型coef_或feature_importances_属性进行排序，并且通过递归消除每个循环中的少量特征，RFE尝试消除模型中可能存在的依赖关系和共线性。</p><p>RFE需要保留指定数量的功能，但是通常事先不知道有多少有效功能。为了找到最佳数量的特征，将交叉验证与RFE一起使用，对不同的特征子集进行评分，并选择最佳的特征评分集合。该RFECV可视化工具绘制的模型特征的数量与他们的交叉验证测试分数和多变性和可视化选择的多项功能一起。</p><p>为了展示其在实际中的工作方式，我们将从一个人为设计的示例开始，该示例使用的数据集中只有25个中的3个信息功能。</p><table><thead><tr><th>可视化器</th><th>RFECV</th></tr></thead><tbody><tr><td>快速使用方法</td><td>rfecv()</td></tr><tr><td>模型</td><td>分类，回归</td></tr><tr><td>工作流程</td><td>选型</td></tr></tbody></table><h3 id="_5-1-基础使用" tabindex="-1"><a class="header-anchor" href="#_5-1-基础使用" aria-hidden="true">#</a> 5.1 基础使用</h3><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>svm <span class="token keyword">import</span> SVC
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> make_classification

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> RFECV

<span class="token comment"># Create a dataset with only 3 informative features</span>
<span class="token comment"># 只有三个有效特征</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> make_classification<span class="token punctuation">(</span>
    n_samples<span class="token operator">=</span><span class="token number">1000</span><span class="token punctuation">,</span> n_features<span class="token operator">=</span><span class="token number">25</span><span class="token punctuation">,</span> n_informative<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">,</span> n_redundant<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span>
    n_repeated<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> n_classes<span class="token operator">=</span><span class="token number">8</span><span class="token punctuation">,</span> n_clusters_per_class<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> random_state<span class="token operator">=</span><span class="token number">0</span>
<span class="token punctuation">)</span>

<span class="token comment"># Instantiate RFECV visualizer with a linear SVM classifier</span>
visualizer <span class="token operator">=</span> RFECV<span class="token punctuation">(</span>SVC<span class="token punctuation">(</span>kernel<span class="token operator">=</span><span class="token string">&#39;linear&#39;</span><span class="token punctuation">,</span> C<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

visualizer<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>        <span class="token comment"># Fit the data to the visualizer</span>
visualizer<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment"># Finalize and render the figure</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_41_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><p>该图显示了一条理想的RFECV曲线，当捕获了三个信息性特征时，该曲线跳至极佳的精度，然后随着将非信息性特征添加到模型中而逐渐降低了精度。阴影区域表示交叉验证的变异性，即曲线绘制的平均准确度得分之上和之下的一个标准偏差。</p><p>探索真实数据集，我们可以看到RFECV对credit默认二进制分类器的影响。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>ensemble <span class="token keyword">import</span> RandomForestClassifier
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> StratifiedKFold

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> RFECV
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_credit

<span class="token comment"># Load classification dataset</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_credit<span class="token punctuation">(</span><span class="token punctuation">)</span>

cv <span class="token operator">=</span> StratifiedKFold<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
visualizer <span class="token operator">=</span> RFECV<span class="token punctuation">(</span>RandomForestClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cv<span class="token operator">=</span>cv<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">&#39;f1_weighted&#39;</span><span class="token punctuation">)</span>

visualizer<span class="token punctuation">.</span>fit<span class="token punctuation">(</span>X<span class="token punctuation">,</span> y<span class="token punctuation">)</span>        <span class="token comment"># Fit the data to the visualizer</span>
visualizer<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span>           <span class="token comment"># Finalize and render the figure</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><pre><code>RFECV(ax=&lt;matplotlib.axes._subplots.AxesSubplot object at 0x7f04351ba190&gt;,
   cv=StratifiedKFold(n_splits=2, random_state=None, shuffle=False),
   groups=None, model=None, scoring=&#39;f1_weighted&#39;, step=1)
</code></pre><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_43_1.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><pre><code>&lt;matplotlib.axes._subplots.AxesSubplot at 0x7f04351ba190&gt;
</code></pre><p>在此示例中，我们可以看到选择了15个特征，尽管在大约5个特征之后，模型的f1得分似乎没有太大改善。选择要消除的特征在确定每次递归的结果中起着很大的作用；修改step参数以在每个步骤中消除一个以上的特征可能有助于尽早消除最差的特征，从而增强其余特征（并且还可以用于加快具有大量特征的数据集的特征消除）。</p><h3 id="_5-2-快速方法" tabindex="-1"><a class="header-anchor" href="#_5-2-快速方法" aria-hidden="true">#</a> 5.2 快速方法</h3><p>上面的相同功能可以通过关联的快速方法来实现rfecv。此方法将RFECV使用关联的参数构建对象，将其拟合，然后（可选）立即显示可视化效果。</p><div class="language-python line-numbers-mode" data-ext="py"><pre class="language-python"><code><span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>ensemble <span class="token keyword">import</span> RandomForestClassifier
<span class="token keyword">from</span> sklearn<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> StratifiedKFold

<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>model_selection <span class="token keyword">import</span> rfecv
<span class="token keyword">from</span> yellowbrick<span class="token punctuation">.</span>datasets <span class="token keyword">import</span> load_credit

<span class="token comment"># Load classification dataset</span>
X<span class="token punctuation">,</span> y <span class="token operator">=</span> load_credit<span class="token punctuation">(</span><span class="token punctuation">)</span>

cv <span class="token operator">=</span> StratifiedKFold<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
visualizer <span class="token operator">=</span> rfecv<span class="token punctuation">(</span>RandomForestClassifier<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> X<span class="token operator">=</span>X<span class="token punctuation">,</span> y<span class="token operator">=</span>y<span class="token punctuation">,</span> cv<span class="token operator">=</span>cv<span class="token punctuation">,</span> scoring<span class="token operator">=</span><span class="token string">&#39;f1_weighted&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://gitlab.com/luohenyueji/article_picture_warehouse/-/raw/main/CSDN/[机器学习] Yellowbrick使用笔记8-模型选择可视化/output_46_0.png" alt="png" tabindex="0" loading="lazy"><figcaption>png</figcaption></figure><h2 id="_6-参考" tabindex="-1"><a class="header-anchor" href="#_6-参考" aria-hidden="true">#</a> 6 参考</h2>`,107),y={href:"https://www.scikit-yb.org/en/latest/api/model_selection/validation_curve.html",target:"_blank",rel:"noopener noreferrer"},f={href:"https://www.scikit-yb.org/en/latest/api/model_selection/learning_curve.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://www.scikit-yb.org/en/latest/api/model_selection/cross_validation.html",target:"_blank",rel:"noopener noreferrer"},q={href:"https://www.scikit-yb.org/en/latest/api/model_selection/importances.html",target:"_blank",rel:"noopener noreferrer"},z={href:"https://www.scikit-yb.org/en/latest/api/model_selection/rfecv.html",target:"_blank",rel:"noopener noreferrer"};function x(F,C){const a=o("ExternalLinkIcon");return i(),p("div",null,[r,u,n("p",null,[n("a",d,[k,e(a)])]),m,v,b,h,n("p",null,[s("有很多方法可以定义如何拆分数据集以进行交叉验证。有关scikit-learn如何实现这些机制的更多信息，请查阅scikit-learn文档中的"),n("a",g,[s("交叉验证：评估估计器性能。"),e(a)])]),_,n("ul",null,[n("li",null,[n("a",y,[s("https://www.scikit-yb.org/en/latest/api/model_selection/validation_curve.html"),e(a)])]),n("li",null,[n("a",f,[s("https://www.scikit-yb.org/en/latest/api/model_selection/learning_curve.html"),e(a)])]),n("li",null,[n("a",w,[s("https://www.scikit-yb.org/en/latest/api/model_selection/cross_validation.html"),e(a)])]),n("li",null,[n("a",q,[s("https://www.scikit-yb.org/en/latest/api/model_selection/importances.html"),e(a)])]),n("li",null,[n("a",z,[s("https://www.scikit-yb.org/en/latest/api/model_selection/rfecv.html"),e(a)])])])])}const V=t(c,[["render",x],["__file","2020-07-25-_机器学习_ Yellowbrick使用笔记8-模型选择可视化.html.vue"]]);export{V as default};
