import{_ as l,c as d,d as a,f as n,b as t,a as i,o as p,r}from"./app-TQoR7mvJ.js";const c={};function u(g,s){const e=r("VPIcon");return p(),d("div",null,[s[11]||(s[11]=a("h1",{id:"编程基础-c-多线程入门10-packaged-task示例",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#编程基础-c-多线程入门10-packaged-task示例"},[a("span",null,"[编程基础] C++多线程入门10-packaged_task示例")])],-1)),s[12]||(s[12]=a("p",null,"原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。",-1)),s[13]||(s[13]=a("h2",{id:"_10-packaged-task-示例",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_10-packaged-task-示例"},[a("span",null,"10 packaged_task<>示例")])],-1)),a("p",null,[s[0]||(s[0]=n("在此示例中，我们将讨论c++11中std")),t(e,{icon:"packaged_task功能及其用法。std"}),s[1]||(s[1]=n("packaged_task<>是一个类模板，代表一个异步任务。它封装了："))]),s[14]||(s[14]=i(`<ol><li>可调用实体，即函数，lambda函数或函数对象。</li><li>一种共享状态，用于存储由关联的回调返回或引发的异常的值。</li></ol><p><strong>需要std::packaged_task&lt;&gt;的情况</strong> 假设我们有一个现有函数，该函数从数据库中获取数据并返回</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// Fetch some data from DB</span></span>
<span class="line"><span>std::string getDataFromDB(std::string token)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	// Do some stuff to fetch the data</span></span>
<span class="line"><span>	std::string data = &quot;Data fetched from DB by Filter::&quot; + token;</span></span>
<span class="line"><span>	return data;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,3)),a("p",null,[s[2]||(s[2]=n("现在，我们要在单独的线程中执行此功能。但是，如何在其他线程完成之后将结果或异常取回主线程呢？ 一种方法是更改​​函数的声明，并在函数中传递std")),t(e,{icon:"promise <>。在线程函数中传递std"}),s[3]||(s[3]=n("promise <>对象之前，先从中获取关联的std")),t(e,{icon:"future <>并将其保留在主线程中。现在，在线程函数返回其值之前，应在传递的std"}),s[4]||(s[4]=n("promise <>参数中设置该值，以便可以在主线程的关联std")),t(e,{icon:`future <>对象中使用它。具体可以见第八篇文章。
但是，如果我们使用std`}),s[5]||(s[5]=n("packaged_task <>，则可以防止创建此std::promise <>和更改功能代码。"))]),s[15]||(s[15]=a("h3",{id:"_10-1-结合使用packaged-task-和函数来创建异步任务",tabindex:"-1"},[a("a",{class:"header-anchor",href:"#_10-1-结合使用packaged-task-和函数来创建异步任务"},[a("span",null,"10.1 结合使用packaged_task <>和函数来创建异步任务")])],-1)),a("p",null,[s[6]||(s[6]=n("std")),t(e,{icon:"packaged_task <>可以包装普通函数，并使其可作为异步函数运行。在单独的线程中调用std"}),s[7]||(s[7]=n(" packaged_task <>时，它将调用关联的回调并将返回值/异常存储在其内部共享状态中。可以通过std:: future <>对象在其他线程或主函数中访问此值。让我们从上述函数创建一个std")),t(e,{icon:`packaged_task <>，在单独的线程中执行，并从其future <>对象获取结果。
**创建std`}),s[8]||(s[8]=n("packaged_task <>对象** std::package_task <>是类模板，因此我们需要将模板参数传递给packaged_task <>，即可调用函数的类型"))]),s[16]||(s[16]=i(`<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// Create a packaged_task&lt;&gt; that encapsulated the callback i.e. a function</span></span>
<span class="line"><span>std::packaged_task&lt;std::string (std::string)&gt; task(getDataFromDB);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>从中获取future对象</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// Fetch the associated future&lt;&gt; from packaged_task&lt;&gt;</span></span>
<span class="line"><span>std::future&lt;std::string&gt; result = task.get_future();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p><strong>将packaged_task &lt;&gt;传递给线程</strong> std::packaged_task &lt;&gt;是可移动的，但不可复制，因此我们需要将其移动到线程，即</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// Pass the packaged_task to thread to run asynchronously</span></span>
<span class="line"><span>std::thread th(std::move(task), &quot;Arg&quot;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,5)),a("p",null,[s[9]||(s[9]=n("由于packaged_task仅可移动且不可复制，因此我们在将其移至线程之前从其获取了std")),t(e,{icon:`future <>对象。线程将执行此任务，该任务在内部调用关联的可调用实体，即我们的函数getDataFromDB()。
现在，当此函数返回值时，std`}),s[10]||(s[10]=n("packaged_task <>会将其设置为关联的共享状态，并且getDataFromDB()返回的结果或异常最终将在关联的future对象中可用。"))]),s[17]||(s[17]=i(`<p><strong>在主函数中，从future &lt;&gt;对象获取结果，即</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>// Fetch the result of packaged_task&lt;&gt; i.e. value returned by getDataFromDB()</span></span>
<span class="line"><span>std::string data =  result.get();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>get()函数将阻塞调用线程，直到可调用实体返回并且std::packaged_task &lt;&gt;将数据设置为可共享状态为止。完整的示例代码如下：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span>#include &lt;thread&gt;</span></span>
<span class="line"><span>#include &lt;future&gt;</span></span>
<span class="line"><span>#include &lt;string&gt;</span></span>
<span class="line"><span>// Fetch some data from DB</span></span>
<span class="line"><span>std::string getDataFromDB(std::string token)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	// Do some stuff to fetch the data</span></span>
<span class="line"><span>	std::string data = &quot;Data fetched from DB by Filter::&quot; + token;</span></span>
<span class="line"><span>	return data;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>int main()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	// Create a packaged_task&lt;&gt; that encapsulated the callback i.e. a function</span></span>
<span class="line"><span>	// 创建封装回调函数的packaged_task&lt;&gt;</span></span>
<span class="line"><span>	std::packaged_task&lt;std::string(std::string)&gt; task(getDataFromDB);</span></span>
<span class="line"><span>	// Fetch the associated future&lt;&gt; from packaged_task&lt;&gt;</span></span>
<span class="line"><span>	// 从packaged_task&lt;&gt;中获取关联的future&lt;&gt;对象</span></span>
<span class="line"><span>	std::future&lt;std::string&gt; result = task.get_future();</span></span>
<span class="line"><span>	// Pass the packaged_task to thread to run asynchronously</span></span>
<span class="line"><span>	// 将packaged_task传递给线程以异步运行</span></span>
<span class="line"><span>	std::thread th(std::move(task), &quot;Arg&quot;);</span></span>
<span class="line"><span>	// Join the thread. Its blocking and returns when thread is finished.</span></span>
<span class="line"><span>	// 加入线程，完成后返回</span></span>
<span class="line"><span>	th.join();</span></span>
<span class="line"><span>	// Fetch the result of packaged_task&lt;&gt; i.e. value returned by getDataFromDB()</span></span>
<span class="line"><span>	// 获取packaged_task&lt;&gt; 的结果，即getDataFromDB（）返回的值</span></span>
<span class="line"><span>	std::string data = result.get();</span></span>
<span class="line"><span>	std::cout &lt;&lt; data &lt;&lt; std::endl;</span></span>
<span class="line"><span>	return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Data fetched from DB by Filter::Arg</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在类似的行中，我们可以创建一个包含lambda函数和函数对象的packaged_task &lt;&gt;，如下所示：</p><p><strong>使用Lambda函数创建packaged_task</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span>#include &lt;thread&gt;</span></span>
<span class="line"><span>#include &lt;future&gt;</span></span>
<span class="line"><span>#include &lt;string&gt;</span></span>
<span class="line"><span>int main()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	// Create a packaged_task&lt;&gt; that encapsulated a lambda function</span></span>
<span class="line"><span>	std::packaged_task&lt;std::string(std::string)&gt; task([](std::string token) {</span></span>
<span class="line"><span>		// Do some stuff to fetch the data</span></span>
<span class="line"><span>		std::string data = &quot;Data From &quot; + token;</span></span>
<span class="line"><span>		return data;</span></span>
<span class="line"><span>	});</span></span>
<span class="line"><span>	// Fetch the associated future&lt;&gt; from packaged_task&lt;&gt;</span></span>
<span class="line"><span>	std::future&lt;std::string&gt; result = task.get_future();</span></span>
<span class="line"><span>	// Pass the packaged_task to thread to run asynchronously</span></span>
<span class="line"><span>	std::thread th(std::move(task), &quot;Arg&quot;);</span></span>
<span class="line"><span>	// Join the thread. Its blocking and returns when thread is finished.</span></span>
<span class="line"><span>	th.join();</span></span>
<span class="line"><span>	// Fetch the result of packaged_task&lt;&gt; i.e. value returned by getDataFromDB()</span></span>
<span class="line"><span>	std::string data = result.get();</span></span>
<span class="line"><span>	std::cout &lt;&lt; data &lt;&lt; std::endl;</span></span>
<span class="line"><span>	return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Data From Arg</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p><strong>使用函数对象创建packaged_task</strong></p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span>#include &lt;thread&gt;</span></span>
<span class="line"><span>#include &lt;future&gt;</span></span>
<span class="line"><span>#include &lt;string&gt;</span></span>
<span class="line"><span>/*</span></span>
<span class="line"><span>* Function Object to Fetch Data from DB</span></span>
<span class="line"><span>*/</span></span>
<span class="line"><span>struct DBDataFetcher</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	std::string operator()(std::string token)</span></span>
<span class="line"><span>	{</span></span>
<span class="line"><span>		// Do some stuff to fetch the data</span></span>
<span class="line"><span>		std::string data = &quot;Data From &quot; + token;</span></span>
<span class="line"><span>		return data;</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span>int main()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	// Create a packaged_task&lt;&gt; that encapsulated a lambda function</span></span>
<span class="line"><span>	std::packaged_task&lt;std::string(std::string)&gt; task(std::move(DBDataFetcher()));</span></span>
<span class="line"><span>	// Fetch the associated future&lt;&gt; from packaged_task&lt;&gt;</span></span>
<span class="line"><span>	std::future&lt;std::string&gt; result = task.get_future();</span></span>
<span class="line"><span>	// Pass the packaged_task to thread to run asynchronously</span></span>
<span class="line"><span>	std::thread th(std::move(task), &quot;Arg&quot;);</span></span>
<span class="line"><span>	// Join the thread. Its blocking and returns when thread is finished.</span></span>
<span class="line"><span>	th.join();</span></span>
<span class="line"><span>	// Fetch the result of packaged_task&lt;&gt; i.e. value returned by getDataFromDB()</span></span>
<span class="line"><span>	std::string data = result.get();</span></span>
<span class="line"><span>	std::cout &lt;&lt; data &lt;&lt; std::endl;</span></span>
<span class="line"><span>	return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Data From Arg</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h3 id="_10-2-参考" tabindex="-1"><a class="header-anchor" href="#_10-2-参考"><span>10.2 参考</span></a></h3><blockquote><p><a href="https://thispointer.com/c11-multithreading-part-10-packaged_task-example-and-tutorial/" target="_blank" rel="noopener noreferrer">https://thispointer.com/c11-multithreading-part-10-packaged_task-example-and-tutorial/</a></p></blockquote>`,17))])}const k=l(c,[["render",u],["__file","2020-05-29-_编程基础_ C__多线程入门10-packaged_task示例.html.vue"]]),v=JSON.parse('{"path":"/blog/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/2020-05-29-_%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_%20C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A810-packaged_task%E7%A4%BA%E4%BE%8B.html","title":"[编程基础] C++多线程入门10-packaged_task示例","lang":"zh-CN","frontmatter":{"date":"2020-05-29T17:31:09.000Z","category":["编程基础"],"tag":["编程基础"],"description":"[编程基础] C++多线程入门10-packaged_task示例 原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。 10 packaged_task<>示例 在此示例中，我们将讨论c++11中std 可调用实体，即函数，l...","head":[["meta",{"property":"og:url","content":"https://luohenyueji.github.io/blog/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/2020-05-29-_%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_%20C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A810-packaged_task%E7%A4%BA%E4%BE%8B.html"}],["meta",{"property":"og:site_name","content":"落痕月极的博客"}],["meta",{"property":"og:title","content":"[编程基础] C++多线程入门10-packaged_task示例"}],["meta",{"property":"og:description","content":"[编程基础] C++多线程入门10-packaged_task示例 原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。 10 packaged_task<>示例 在此示例中，我们将讨论c++11中std 可调用实体，即函数，l..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"编程基础"}],["meta",{"property":"article:published_time","content":"2020-05-29T17:31:09.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"[编程基础] C++多线程入门10-packaged_task示例\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-05-29T17:31:09.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"落痕月极\\",\\"url\\":\\"/\\"}]}"]]},"headers":[{"level":2,"title":"10 packaged_task<>示例","slug":"_10-packaged-task-示例","link":"#_10-packaged-task-示例","children":[{"level":3,"title":"10.1 结合使用packaged_task <>和函数来创建异步任务","slug":"_10-1-结合使用packaged-task-和函数来创建异步任务","link":"#_10-1-结合使用packaged-task-和函数来创建异步任务","children":[]},{"level":3,"title":"10.2 参考","slug":"_10-2-参考","link":"#_10-2-参考","children":[]}]}],"git":{},"readingTime":{"minutes":4.6,"words":1380},"filePathRelative":"blog/编程基础/C++多线程入门/2020-05-29-[编程基础] C++多线程入门10-packaged_task示例.md","localizedDate":"2020年5月30日","excerpt":"\\n<p>原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。</p>\\n<h2>10 packaged_task&lt;&gt;示例</h2>\\n<p>在此示例中，我们将讨论c++11中std</p>\\n<ol>\\n<li>可调用实体，即函数，lambda函数或函数对象。</li>\\n<li>一种共享状态，用于存储由关联的回调返回或引发的异常的值。</li>\\n</ol>\\n<p><strong>需要std::packaged_task&lt;&gt;的情况</strong>\\n假设我们有一个现有函数，该函数从数据库中获取数据并返回</p>","autoDesc":true}');export{k as comp,v as data};
