import{_ as s}from"./plugin-vue_export-helper-x3n3nnut.js";import{r as i,o as d,c as r,a as e,b as n,d as a,e as l}from"./app-MsA2k2kn.js";const u={},o=l(`<h1 id="编程基础-c-多线程入门8-从线程返回值" tabindex="-1"><a class="header-anchor" href="#编程基础-c-多线程入门8-从线程返回值" aria-hidden="true">#</a> [编程基础] C++多线程入门8-从线程返回值</h1><p>原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。</p><h2 id="_8-从线程返回值" tabindex="-1"><a class="header-anchor" href="#_8-从线程返回值" aria-hidden="true">#</a> 8 从线程返回值</h2><h3 id="_8-1-使用说明" tabindex="-1"><a class="header-anchor" href="#_8-1-使用说明" aria-hidden="true">#</a> 8.1 使用说明</h3><p>一个std::future对象可以与asych，std::packaged_task和std::promise一起使用。本文将主要关注将std::future与std::promise对象一起使用。很多时候，我们遇到希望线程返回结果的情况。现在的问题是如何做到这一点？ 让我们举个例子假设在我们的应用程序中，我们创建了一个将压缩给定文件夹的线程，并且我们希望该线程返回新的zip文件名及其结果。现在，我们有两种方法： <strong>使用指针在线程之间共享数据</strong></p><p>将指针传递给新线程，此线程将设置其中的数据。在此之前，在主线程中使用条件变量继续等待。当新线程设置数据并向条件变量发送信号时，主线程将唤醒并从该指针获取数据。为了简单起见，我们使用了一个条件变量，一个互斥锁和一个指针(即3个项)来捕获返回的值。为那么问题将变得更加复杂。有没有一个简单的方法从线程返回值。答案是肯定的，使用std::future，让我们看看下一个解决方案。</p><p><strong>C++11方式：使用std::future和std::promise</strong></p><p>std::future是一个类模板，其对象存储将来的值。那么这future模板有什么用？实际上，一个std::future对象在内部存储了将来将分配的值，并且还提供了一种访问该值的机制，即使用get()成员函数。但是，如果有人尝试在get()函数可用之前访问future的此关联值，则get()函数将阻塞直到该值不可用。 std::promise也是一个类模板，其对象承诺将来会设置该值。每个std::promise对象都有一个关联的std::future对象，一旦std::promise对象设置了该值，它将给出该值。一个std::promise对象与其关联的std::future对象共享数据。让我们一步一步来看看，在Thread1中创建一个std::promise对象。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>std::promise&lt;int&gt; promiseObj;
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>截至目前，该promise对象没有任何关联值。但是它提供了一个保证，肯定有人会在其中设置值，一旦设置了值，您就可以通过关联的std::future对象获得该值。但是现在假设线程1创建了这个promise对象并将其传递给线程2对象。现在，线程1如何知道何时线程2将在此promise对象中设置值？ 答案是使用std::future对象。每个std::promise对象都有一个关联的std::future对象，其他对象可以通过该对象获取promise设置的值。 现在，线程1将把promiseObj传递给线程2。然后线程1将通过std::future的get函数获取线程2在std::promise中设置的值。</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>	int val = futureObj.get();
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>但是，如果线程2尚未设置值，则此调用将被阻塞，直到线程2在promise对象中设置值，即</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>	promiseObj.set_value(45);
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>在下图中查看完整流程：</p><figure><img src="https://img-blog.csdnimg.cn/20200529170920768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1b2hlbllK,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure><p>让我们看一个完整的std::future和std::promise示例，</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>#include &lt;iostream&gt;
#include &lt;thread&gt;
#include &lt;future&gt;
void initiazer(std::promise&lt;int&gt; * promObj)
{
    std::cout&lt;&lt;&quot;Inside Thread&quot;&lt;&lt;std::endl;     promObj-&gt;set_value(35);
}
int main()
{
    std::promise&lt;int&gt; promiseObj;
    std::future&lt;int&gt; futureObj = promiseObj.get_future();
    std::thread th(initiazer, &amp;promiseObj);
    std::cout&lt;&lt;futureObj.get()&lt;&lt;std::endl;
    th.join();
    return 0;
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为：</p><div class="language-text line-numbers-mode" data-ext="text"><pre class="language-text"><code>Inside Thread
35
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此外，如果您希望线程在不同的时间点返回多个值，则只需在线程中传递多个std::promise对象，然后从关联的多个std::future对象中获取多个返回值。在下一篇文章中，我们将看到如何将std::future与std::asych和std::packaged_task结合使用。</p><h3 id="_8-2-参考" tabindex="-1"><a class="header-anchor" href="#_8-2-参考" aria-hidden="true">#</a> 8.2 参考</h3>`,21),c={href:"https://thispointer.com//c11-multithreading-part-8-stdfuture-stdpromise-and-returning-values-from-thread/",target:"_blank",rel:"noopener noreferrer"};function m(p,v){const t=i("ExternalLinkIcon");return d(),r("div",null,[o,e("blockquote",null,[e("p",null,[e("a",c,[n("https://thispointer.com//c11-multithreading-part-8-stdfuture-stdpromise-and-returning-values-from-thread/"),a(t)])])])])}const b=s(u,[["render",m],["__file","2020-05-29-_编程基础_ C__多线程入门8-从线程返回值.html.vue"]]);export{b as default};
