import{_ as l,c as r,a,d as i,f as e,b as t,o as d,r as p}from"./app-TQoR7mvJ.js";const o={};function u(m,s){const n=p("VPIcon");return d(),r("div",null,[s[20]||(s[20]=a('<h1 id="编程基础-c-多线程入门8-从线程返回值" tabindex="-1"><a class="header-anchor" href="#编程基础-c-多线程入门8-从线程返回值"><span>[编程基础] C++多线程入门8-从线程返回值</span></a></h1><p>原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。</p><h2 id="_8-从线程返回值" tabindex="-1"><a class="header-anchor" href="#_8-从线程返回值"><span>8 从线程返回值</span></a></h2><h3 id="_8-1-使用说明" tabindex="-1"><a class="header-anchor" href="#_8-1-使用说明"><span>8.1 使用说明</span></a></h3>',4)),i("p",null,[s[0]||(s[0]=e("一个std")),t(n,{icon:"future对象可以与asych，std"}),s[1]||(s[1]=e("packaged_task和std")),t(n,{icon:"promise一起使用。本文将主要关注将std"}),s[2]||(s[2]=e("future与std::promise对象一起使用。很多时候，我们遇到希望线程返回结果的情况。现在的问题是如何做到这一点？ 让我们举个例子假设在我们的应用程序中，我们创建了一个将压缩给定文件夹的线程，并且我们希望该线程返回新的zip文件名及其结果。现在，我们有两种方法： ")),s[3]||(s[3]=i("strong",null,"使用指针在线程之间共享数据",-1))]),s[21]||(s[21]=i("p",null,"将指针传递给新线程，此线程将设置其中的数据。在此之前，在主线程中使用条件变量继续等待。当新线程设置数据并向条件变量发送信号时，主线程将唤醒并从该指针获取数据。为了简单起见，我们使用了一个条件变量，一个互斥锁和一个指针(即3个项)来捕获返回的值。为那么问题将变得更加复杂。有没有一个简单的方法从线程返回值。答案是肯定的，使用std::future，让我们看看下一个解决方案。",-1)),i("p",null,[i("strong",null,[s[4]||(s[4]=e("C++11方式：使用std")),t(n,{icon:"future和std"}),s[5]||(s[5]=e("promise"))])]),i("p",null,[s[6]||(s[6]=e("std")),t(n,{icon:"future是一个类模板，其对象存储将来的值。那么这future模板有什么用？实际上，一个std"}),s[7]||(s[7]=e("future对象在内部存储了将来将分配的值，并且还提供了一种访问该值的机制，即使用get()成员函数。但是，如果有人尝试在get()函数可用之前访问future的此关联值，则get()函数将阻塞直到该值不可用。 std")),t(n,{icon:"promise也是一个类模板，其对象承诺将来会设置该值。每个std"}),s[8]||(s[8]=e("promise对象都有一个关联的std")),t(n,{icon:"future对象，一旦std"}),s[9]||(s[9]=e("promise对象设置了该值，它将给出该值。一个std")),t(n,{icon:"promise对象与其关联的std"}),s[10]||(s[10]=e("future对象共享数据。让我们一步一步来看看，在Thread1中创建一个std::promise对象。"))]),s[22]||(s[22]=a('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>std::promise&lt;int&gt; promiseObj;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',1)),i("p",null,[s[11]||(s[11]=e("截至目前，该promise对象没有任何关联值。但是它提供了一个保证，肯定有人会在其中设置值，一旦设置了值，您就可以通过关联的std")),t(n,{icon:`future对象获得该值。但是现在假设线程1创建了这个promise对象并将其传递给线程2对象。现在，线程1如何知道何时线程2将在此promise对象中设置值？
答案是使用std`}),s[12]||(s[12]=e("future对象。每个std")),t(n,{icon:"promise对象都有一个关联的std"}),s[13]||(s[13]=e("future对象，其他对象可以通过该对象获取promise设置的值。 现在，线程1将把promiseObj传递给线程2。然后线程1将通过std")),t(n,{icon:"future的get函数获取线程2在std"}),s[14]||(s[14]=e("promise中设置的值。"))]),s[23]||(s[23]=a('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>	int val = futureObj.get();</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>但是，如果线程2尚未设置值，则此调用将被阻塞，直到线程2在promise对象中设置值，即</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>	promiseObj.set_value(45);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>在下图中查看完整流程：</p><figure><img src="https://img-blog.csdnimg.cn/20200529170920768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1b2hlbllK,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" tabindex="0" loading="lazy"><figcaption>在这里插入图片描述</figcaption></figure>',5)),i("p",null,[s[15]||(s[15]=e("让我们看一个完整的std")),t(n,{icon:"future和std"}),s[16]||(s[16]=e("promise示例，"))]),s[24]||(s[24]=a(`<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span>#include &lt;thread&gt;</span></span>
<span class="line"><span>#include &lt;future&gt;</span></span>
<span class="line"><span>void initiazer(std::promise&lt;int&gt; * promObj)</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    std::cout&lt;&lt;&quot;Inside Thread&quot;&lt;&lt;std::endl;     promObj-&gt;set_value(35);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>int main()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>    std::promise&lt;int&gt; promiseObj;</span></span>
<span class="line"><span>    std::future&lt;int&gt; futureObj = promiseObj.get_future();</span></span>
<span class="line"><span>    std::thread th(initiazer, &amp;promiseObj);</span></span>
<span class="line"><span>    std::cout&lt;&lt;futureObj.get()&lt;&lt;std::endl;</span></span>
<span class="line"><span>    th.join();</span></span>
<span class="line"><span>    return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Inside Thread</span></span>
<span class="line"><span>35</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div>`,3)),i("p",null,[s[17]||(s[17]=e("此外，如果您希望线程在不同的时间点返回多个值，则只需在线程中传递多个std")),t(n,{icon:"promise对象，然后从关联的多个std"}),s[18]||(s[18]=e("future对象中获取多个返回值。在下一篇文章中，我们将看到如何将std")),t(n,{icon:"future与std"}),s[19]||(s[19]=e("asych和std::packaged_task结合使用。"))]),s[25]||(s[25]=i("h3",{id:"_8-2-参考",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#_8-2-参考"},[i("span",null,"8.2 参考")])],-1)),s[26]||(s[26]=i("blockquote",null,[i("p",null,[i("a",{href:"https://thispointer.com//c11-multithreading-part-8-stdfuture-stdpromise-and-returning-values-from-thread/",target:"_blank",rel:"noopener noreferrer"},"https://thispointer.com//c11-multithreading-part-8-stdfuture-stdpromise-and-returning-values-from-thread/")])],-1))])}const b=l(o,[["render",u],["__file","2020-05-29-_编程基础_ C__多线程入门8-从线程返回值.html.vue"]]),h=JSON.parse('{"path":"/blog/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/2020-05-29-_%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_%20C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A88-%E4%BB%8E%E7%BA%BF%E7%A8%8B%E8%BF%94%E5%9B%9E%E5%80%BC.html","title":"[编程基础] C++多线程入门8-从线程返回值","lang":"zh-CN","frontmatter":{"date":"2020-05-29T17:09:34.000Z","category":["编程基础"],"tag":["编程基础"],"description":"[编程基础] C++多线程入门8-从线程返回值 原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。 8 从线程返回值 8.1 使用说明 一个std 将指针传递给新线程，此线程将设置其中的数据。在此之前，在主线程中使用条件变量继...","head":[["meta",{"property":"og:url","content":"https://luohenyueji.github.io/blog/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/2020-05-29-_%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_%20C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A88-%E4%BB%8E%E7%BA%BF%E7%A8%8B%E8%BF%94%E5%9B%9E%E5%80%BC.html"}],["meta",{"property":"og:site_name","content":"落痕月极的博客"}],["meta",{"property":"og:title","content":"[编程基础] C++多线程入门8-从线程返回值"}],["meta",{"property":"og:description","content":"[编程基础] C++多线程入门8-从线程返回值 原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。 8 从线程返回值 8.1 使用说明 一个std 将指针传递给新线程，此线程将设置其中的数据。在此之前，在主线程中使用条件变量继..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://img-blog.csdnimg.cn/20200529170920768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1b2hlbllK,size_16,color_FFFFFF,t_70#pic_center"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"编程基础"}],["meta",{"property":"article:published_time","content":"2020-05-29T17:09:34.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"[编程基础] C++多线程入门8-从线程返回值\\",\\"image\\":[\\"https://img-blog.csdnimg.cn/20200529170920768.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0x1b2hlbllK,size_16,color_FFFFFF,t_70#pic_center\\"],\\"datePublished\\":\\"2020-05-29T17:09:34.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"落痕月极\\",\\"url\\":\\"/\\"}]}"]]},"headers":[{"level":2,"title":"8 从线程返回值","slug":"_8-从线程返回值","link":"#_8-从线程返回值","children":[{"level":3,"title":"8.1 使用说明","slug":"_8-1-使用说明","link":"#_8-1-使用说明","children":[]},{"level":3,"title":"8.2 参考","slug":"_8-2-参考","link":"#_8-2-参考","children":[]}]}],"git":{},"readingTime":{"minutes":3.61,"words":1082},"filePathRelative":"blog/编程基础/C++多线程入门/2020-05-29-[编程基础] C++多线程入门8-从线程返回值.md","localizedDate":"2020年5月30日","excerpt":"\\n<p>原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。</p>\\n<h2>8 从线程返回值</h2>\\n<h3>8.1 使用说明</h3>\\n<p>一个std</p>\\n<p>将指针传递给新线程，此线程将设置其中的数据。在此之前，在主线程中使用条件变量继续等待。当新线程设置数据并向条件变量发送信号时，主线程将唤醒并从该指针获取数据。为了简单起见，我们使用了一个条件变量，一个互斥锁和一个指针(即3个项)来捕获返回的值。为那么问题将变得更加复杂。有没有一个简单的方法从线程返回值。答案是肯定的，使用std::future，让我们看看下一个解决方案。</p>","autoDesc":true}');export{b as comp,h as data};
