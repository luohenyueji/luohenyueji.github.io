import{_ as t,c as d,d as n,e as a,b as e,a as l,o as p,r}from"./app-BOswGe5u.js";const c={};function h(o,s){const i=r("VPIcon");return p(),d("div",null,[s[7]||(s[7]=n("p",null,"原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。",-1)),s[8]||(s[8]=n("h1",{id:"编程基础-c-多线程入门1-创建线程的三种不同方式",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#编程基础-c-多线程入门1-创建线程的三种不同方式"},[n("span",null,"[编程基础] C++多线程入门1-创建线程的三种不同方式")])],-1)),s[9]||(s[9]=n("h2",{id:"_1-创建线程的三种不同方式",tabindex:"-1"},[n("a",{class:"header-anchor",href:"#_1-创建线程的三种不同方式"},[n("span",null,"1 创建线程的三种不同方式")])],-1)),n("p",null,[s[0]||(s[0]=a("在本章中，我们将讨论如何使用std")),e(i,{icon:`thread在C++11中创建线程。  
在每个C++应用程序中，都有一个默认的主线程，即main()函数。在C++11中，我们可以通过创建std`}),s[1]||(s[1]=a("thread类的对象来创建其他线程。每个std::thread对象都可以与一个线程关联。因此我们需要引入头文件为："))]),s[10]||(s[10]=l('<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;thread&gt;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>',1)),n("p",null,[s[2]||(s[2]=a("那么std")),e(i,{icon:"thread在构造函数中接受什么？我们可以在std"}),s[3]||(s[3]=a("thread对象上附加一个回调，该回调将在新线程启动时执行。这些回调可以是："))]),s[11]||(s[11]=l(`<ol><li>函数指针</li><li>函数对象</li><li>Lambda函数</li></ol><h3 id="_1-1-创建线程" tabindex="-1"><a class="header-anchor" href="#_1-1-创建线程"><span>1.1 创建线程</span></a></h3><p>可以这样创建线程对象：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>std::thread thObj(&lt;CALLBACK&gt;);</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>新线程将在创建新对象后立即启动，并将与启动该线程的线程并行执行传递的回调。而且，任何线程都可以通过在该线程的对象上调用join()函数来等待另一个线程退出。 让我们看一个示例，其中主线程将创建一个单独的线程。创建此新线程后，主线程将在控制台上打印一些数据，然后等待新创建的线程退出。我们使用三种不同的回调机制来实现上述功能。</p><ol><li>使用函数指针创建线程</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;thread&gt;</span></span>
<span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>using namespace std;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void thread_function()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	for (int i = 0; i &lt; 10000; i++);</span></span>
<span class="line"><span>	std::cout &lt;&lt; &quot;thread function Executing&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	// 创建线程 </span></span>
<span class="line"><span>	std::thread threadObj(thread_function);</span></span>
<span class="line"><span>	for (int i = 0; i &lt; 10000; i++);</span></span>
<span class="line"><span>	std::cout &lt;&lt; &quot;Display From MainThread&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span>	// 等待线程的结束</span></span>
<span class="line"><span>	threadObj.join();</span></span>
<span class="line"><span>	std::cout &lt;&lt; &quot;Exit of Main function&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span>	return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Display From MainThreadthread function Executing</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Exit of Main function</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="2"><li>使用函数对象创建线程</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span>#include &lt;thread&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>class DisplayThread</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>public:</span></span>
<span class="line"><span>	void operator()()</span></span>
<span class="line"><span>	{</span></span>
<span class="line"><span>		for (int i = 0; i &lt; 10000; i++);</span></span>
<span class="line"><span>		std::cout &lt;&lt; &quot;Display Thread Executing&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span>	}</span></span>
<span class="line"><span>};</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	std::thread threadObj((DisplayThread()));</span></span>
<span class="line"><span>	for (int i = 0; i &lt; 10000; i++);</span></span>
<span class="line"><span>	std::cout &lt;&lt; &quot;Display From Main Thread &quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span>	std::cout &lt;&lt; &quot;Waiting For Thread to complete&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span>	threadObj.join();</span></span>
<span class="line"><span>	std::cout &lt;&lt; &quot;Exiting from Main Thread&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span>	return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Display Thread ExecutingDisplay From Main Thread</span></span>
<span class="line"><span>Waiting For Thread to complete</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Exiting from Main Thread</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><ol start="3"><li>使用Lambda函数创建线程</li></ol><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span>#include &lt;thread&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>int main()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	int x = 9;</span></span>
<span class="line"><span>	std::thread threadObj([] {</span></span>
<span class="line"><span>		for (int i = 0; i &lt; 10000; i++)</span></span>
<span class="line"><span>			std::cout &lt;&lt; &quot;Display Thread Executing&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span>	});</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	for (int i = 0; i &lt; 10000; i++)</span></span>
<span class="line"><span>		std::cout &lt;&lt; &quot;Display From Main Thread&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	threadObj.join();</span></span>
<span class="line"><span>	std::cout &lt;&lt; &quot;Exiting from Main Thread&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span>	return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Display Thread ExecutingDisplay From Main Thread</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Exiting from Main Thread</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-2-区分线程" tabindex="-1"><a class="header-anchor" href="#_1-2-区分线程"><span>1.2 区分线程</span></a></h3><p>每个std::thread对象都有一个关联的ID，我们可以使用成员函数来获取，给出关联的thread对象的ID。</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>std::thread::get_id()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>要获取当前线程使用的标识符,即</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>std::this_thread::get_id()</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div>`,22)),n("p",null,[s[4]||(s[4]=a("如果std")),e(i,{icon:"thread对象没有关联的线程，则get_id()将返回默认构造的std"}),s[5]||(s[5]=a("thread")),e(i,{icon:"id对象，即“没有任何线程”。std"}),s[6]||(s[6]=a("thread::id是一个Object，也可以在控制台上进行比较和打印。让我们看一个例子。"))]),s[12]||(s[12]=l(`<div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>#include &lt;iostream&gt;</span></span>
<span class="line"><span>#include &lt;thread&gt;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void thread_function()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	std::cout &lt;&lt; &quot;Inside Thread::ID  = &quot; &lt;&lt; std::this_thread::get_id() &lt;&lt; std::endl;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span>int main()</span></span>
<span class="line"><span>{</span></span>
<span class="line"><span>	std::thread threadObj1(thread_function);</span></span>
<span class="line"><span>	std::thread threadObj2(thread_function);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	if (threadObj1.get_id() != threadObj2.get_id())</span></span>
<span class="line"><span>		std::cout &lt;&lt; &quot;Both Threads have different IDs&quot; &lt;&lt; std::endl;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	std::cout &lt;&lt; &quot;From Main Thread::ID of Thread 1 = &quot; &lt;&lt; threadObj1.get_id() &lt;&lt; std::endl;</span></span>
<span class="line"><span>	std::cout &lt;&lt; &quot;From Main Thread::ID of Thread 2 = &quot; &lt;&lt; threadObj2.get_id() &lt;&lt; std::endl;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>	threadObj1.join();</span></span>
<span class="line"><span>	threadObj2.join();</span></span>
<span class="line"><span>	return 0;</span></span>
<span class="line"><span>}</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>输出为：</p><div class="language- line-numbers-mode" data-highlighter="shiki" data-ext="" data-title="" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span>Inside Thread::ID? = 14756</span></span>
<span class="line"><span>Inside Thread::ID? = 15500</span></span>
<span class="line"><span>Both Threads have different IDs</span></span>
<span class="line"><span>From Main Thread::ID of Thread 1 = 14756</span></span>
<span class="line"><span>From Main Thread::ID of Thread 2 = 15500</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="_1-3-参考" tabindex="-1"><a class="header-anchor" href="#_1-3-参考"><span>1.3 参考</span></a></h3><blockquote><p><a href="https://thispointer.com//c-11-multithreading-part-1-three-different-ways-to-create-threads/" target="_blank" rel="noopener noreferrer">https://thispointer.com//c-11-multithreading-part-1-three-different-ways-to-create-threads/</a></p></blockquote>`,5))])}const u=t(c,[["render",h],["__file","2020-05-29-_编程基础_ C__多线程入门1-创建线程的三种不同方式.html.vue"]]),b=JSON.parse('{"path":"/blog/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/2020-05-29-_%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_%20C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A81-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F.html","title":"[编程基础] C++多线程入门1-创建线程的三种不同方式","lang":"zh-CN","frontmatter":{"date":"2020-05-29T16:30:50.000Z","category":["编程基础"],"tag":["编程基础"],"description":"原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。 [编程基础] C++多线程入门1-创建线程的三种不同方式 1 创建线程的三种不同方式 在本章中，我们将讨论如何使用std 那么std 函数指针 函数对象 Lambda函数 1...","head":[["meta",{"property":"og:url","content":"https://luohenyueji.github.io/blog/%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80/C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A8/2020-05-29-_%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80_%20C__%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%85%A5%E9%97%A81-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%89%E7%A7%8D%E4%B8%8D%E5%90%8C%E6%96%B9%E5%BC%8F.html"}],["meta",{"property":"og:site_name","content":"落痕月极的博客"}],["meta",{"property":"og:title","content":"[编程基础] C++多线程入门1-创建线程的三种不同方式"}],["meta",{"property":"og:description","content":"原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。 [编程基础] C++多线程入门1-创建线程的三种不同方式 1 创建线程的三种不同方式 在本章中，我们将讨论如何使用std 那么std 函数指针 函数对象 Lambda函数 1..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:tag","content":"编程基础"}],["meta",{"property":"article:published_time","content":"2020-05-29T16:30:50.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"[编程基础] C++多线程入门1-创建线程的三种不同方式\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2020-05-29T16:30:50.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"落痕月极\\",\\"url\\":\\"/\\"}]}"]]},"headers":[{"level":2,"title":"1 创建线程的三种不同方式","slug":"_1-创建线程的三种不同方式","link":"#_1-创建线程的三种不同方式","children":[{"level":3,"title":"1.1 创建线程","slug":"_1-1-创建线程","link":"#_1-1-创建线程","children":[]},{"level":3,"title":"1.2 区分线程","slug":"_1-2-区分线程","link":"#_1-2-区分线程","children":[]},{"level":3,"title":"1.3 参考","slug":"_1-3-参考","link":"#_1-3-参考","children":[]}]}],"git":{},"readingTime":{"minutes":3.17,"words":952},"filePathRelative":"blog/编程基础/C++多线程入门/2020-05-29-[编程基础] C++多线程入门1-创建线程的三种不同方式.md","localizedDate":"2020年5月30日","excerpt":"<p>原始C++标准仅支持单线程编程。新的C++标准(称为C++11或C++0x)于2011年发布。在C++11中，引入了新的线程库。因此运行本文程序需要C++至少符合C++11标准。</p>\\n<h1>[编程基础] C++多线程入门1-创建线程的三种不同方式</h1>\\n<h2>1 创建线程的三种不同方式</h2>\\n<p>在本章中，我们将讨论如何使用std</p>\\n<div class=\\"language- line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"\\" data-title=\\"\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span>#include &lt;thread&gt;</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{u as comp,b as data};
