const t=JSON.parse('{"key":"v-007db673","path":"/blog/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/YUV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/2018-12-11-_%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%20YUV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A84.html","title":"[图像处理] YUV图像处理入门4","lang":"zh-CN","frontmatter":{"date":"2018-12-11T17:35:44.000Z","category":["图像处理"],"tag":["图像处理"],"description":"[图像处理] YUV图像处理入门4 9 yuv420图像截取 本程序中的函数主要是对YUV420P视频数据流的第一帧图像进行截取。类似opencv中的rect函数，函数的代码如下所示： /** * @file 9 yuv_clip.cpp * @author luohen * @brief yuv image clip * @date 2018-12-08 * */ #include \\"stdafx.h\\" #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; #include &lt;iostream&gt; using namespace std; /** * @brief * * @param w width of input yuv420p file * @param h height of input yuv420p file * @param sx clipped initial position x of origin y image * @param sy clipped initial position y of origin y image * @param sw wdith of clipped image * @param sh height of clipped image * @param url location of input yuv420p file * @return int */ int yuv420_clip(int w, int h, int sx, int sy, int sw, int sh, const char *url) { \\t//reading yuv file \\tFILE *input_fp; \\t//writing yuv file \\tFILE *output_fp = fopen(\\"video_result/output_clip.yuv\\", \\"wb+\\"); \\tif ((input_fp = fopen(url, \\"rb\\")) == NULL) \\t{ \\t\\tprintf(\\"%s open error!\\\\n\\", url); \\t\\treturn -1; \\t} \\telse \\t{ \\t\\tprintf(\\"%s open.\\\\n\\", url); \\t} \\t//origin image \\tunsigned char *pic = new unsigned char[w * h * 3 / 2]; \\t//clipped image \\tunsigned char *pic_clip = new unsigned char[sw * sh * 3 / 2]; \\t// y length of origin image \\tint size_y = w * h; \\t// yu length of origin image \\tint size_yu = w * h + w * h / 4; \\t// y length of clipped image \\tint size_sy = sw * sh; \\t// yu length of clipped image \\tint size_syu = sw * sh + sw * sh / 4; \\tfread(pic, sizeof(unsigned char), w * h * 3 / 2, input_fp); \\t//y clip \\tfor (int j = 0; j &lt; sh; j++) \\t{ \\t\\tfor (int k = 0; k &lt; sw; k++) \\t\\t{ \\t\\t\\tpic_clip[j * sw + k] = pic[(sx + j) * w + (sy + k)]; \\t\\t} \\t} \\t//sw_uv,sh_uv \\tint sw_uv = sw / 2; \\tint sh_uv = sh / 2; \\t//u clip \\tfor (int j = 0; j &lt; sh_uv; j++) \\t{ \\t\\tfor (int k = 0; k &lt; sw_uv; k++) \\t\\t{ \\t\\t\\tpic_clip[size_sy + j * sw_uv + k] = pic[size_y + (sx / 2 + j) * w / 2 + (sy / 2 + k)]; \\t\\t} \\t} \\t//v clip \\tfor (int j = 0; j &lt; sh_uv; j++) \\t{ \\t\\tfor (int k = 0; k &lt; sw_uv; k++) \\t\\t{ \\t\\t\\tpic_clip[size_syu + j * sw_uv + k] = pic[size_yu + (sx / 2 + j) * w / 2 + (sy / 2 + k)]; \\t\\t} \\t} \\tfwrite(pic_clip, 1, sw * sh * 3 / 2, output_fp); \\tdelete[] pic; \\tdelete[] pic_clip; \\tfclose(input_fp); \\tfclose(output_fp); \\treturn 0; } /** * @brief main * * @return int */ int main() { \\tint state = yuv420_clip(352, 288, 60, 50, 176, 144, \\"video/akiyo.yuv\\"); \\treturn 0; }","head":[["meta",{"property":"og:url","content":"https://luohenyueji.github.io/blog/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/YUV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A8/2018-12-11-_%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86_%20YUV%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86%E5%85%A5%E9%97%A84.html"}],["meta",{"property":"og:site_name","content":"落痕月极的博客"}],["meta",{"property":"og:title","content":"[图像处理] YUV图像处理入门4"}],["meta",{"property":"og:description","content":"[图像处理] YUV图像处理入门4 9 yuv420图像截取 本程序中的函数主要是对YUV420P视频数据流的第一帧图像进行截取。类似opencv中的rect函数，函数的代码如下所示： /** * @file 9 yuv_clip.cpp * @author luohen * @brief yuv image clip * @date 2018-12-08 * */ #include \\"stdafx.h\\" #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include &lt;string.h&gt; #include &lt;math.h&gt; #include &lt;iostream&gt; using namespace std; /** * @brief * * @param w width of input yuv420p file * @param h height of input yuv420p file * @param sx clipped initial position x of origin y image * @param sy clipped initial position y of origin y image * @param sw wdith of clipped image * @param sh height of clipped image * @param url location of input yuv420p file * @return int */ int yuv420_clip(int w, int h, int sx, int sy, int sw, int sh, const char *url) { \\t//reading yuv file \\tFILE *input_fp; \\t//writing yuv file \\tFILE *output_fp = fopen(\\"video_result/output_clip.yuv\\", \\"wb+\\"); \\tif ((input_fp = fopen(url, \\"rb\\")) == NULL) \\t{ \\t\\tprintf(\\"%s open error!\\\\n\\", url); \\t\\treturn -1; \\t} \\telse \\t{ \\t\\tprintf(\\"%s open.\\\\n\\", url); \\t} \\t//origin image \\tunsigned char *pic = new unsigned char[w * h * 3 / 2]; \\t//clipped image \\tunsigned char *pic_clip = new unsigned char[sw * sh * 3 / 2]; \\t// y length of origin image \\tint size_y = w * h; \\t// yu length of origin image \\tint size_yu = w * h + w * h / 4; \\t// y length of clipped image \\tint size_sy = sw * sh; \\t// yu length of clipped image \\tint size_syu = sw * sh + sw * sh / 4; \\tfread(pic, sizeof(unsigned char), w * h * 3 / 2, input_fp); \\t//y clip \\tfor (int j = 0; j &lt; sh; j++) \\t{ \\t\\tfor (int k = 0; k &lt; sw; k++) \\t\\t{ \\t\\t\\tpic_clip[j * sw + k] = pic[(sx + j) * w + (sy + k)]; \\t\\t} \\t} \\t//sw_uv,sh_uv \\tint sw_uv = sw / 2; \\tint sh_uv = sh / 2; \\t//u clip \\tfor (int j = 0; j &lt; sh_uv; j++) \\t{ \\t\\tfor (int k = 0; k &lt; sw_uv; k++) \\t\\t{ \\t\\t\\tpic_clip[size_sy + j * sw_uv + k] = pic[size_y + (sx / 2 + j) * w / 2 + (sy / 2 + k)]; \\t\\t} \\t} \\t//v clip \\tfor (int j = 0; j &lt; sh_uv; j++) \\t{ \\t\\tfor (int k = 0; k &lt; sw_uv; k++) \\t\\t{ \\t\\t\\tpic_clip[size_syu + j * sw_uv + k] = pic[size_yu + (sx / 2 + j) * w / 2 + (sy / 2 + k)]; \\t\\t} \\t} \\tfwrite(pic_clip, 1, sw * sh * 3 / 2, output_fp); \\tdelete[] pic; \\tdelete[] pic_clip; \\tfclose(input_fp); \\tfclose(output_fp); \\treturn 0; } /** * @brief main * * @return int */ int main() { \\tint state = yuv420_clip(352, 288, 60, 50, 176, 144, \\"video/akiyo.yuv\\"); \\treturn 0; }"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"article:author","content":"落痕月极"}],["meta",{"property":"article:tag","content":"图像处理"}],["meta",{"property":"article:published_time","content":"2018-12-11T17:35:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"[图像处理] YUV图像处理入门4\\",\\"image\\":[\\"\\"],\\"datePublished\\":\\"2018-12-11T17:35:44.000Z\\",\\"dateModified\\":null,\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"落痕月极\\",\\"url\\":\\"/\\"}]}"]]},"headers":[{"level":2,"title":"9 yuv420图像截取","slug":"_9-yuv420图像截取","link":"#_9-yuv420图像截取","children":[]},{"level":2,"title":"10 yuv420图像帧差法运动检测","slug":"_10-yuv420图像帧差法运动检测","link":"#_10-yuv420图像帧差法运动检测","children":[]},{"level":2,"title":"11 二值图像膨胀和腐蚀","slug":"_11-二值图像膨胀和腐蚀","link":"#_11-二值图像膨胀和腐蚀","children":[]}],"git":{},"readingTime":{"minutes":9.71,"words":2913},"filePathRelative":"blog/图像处理/YUV图像处理入门/2018-12-11-[图像处理] YUV图像处理入门4.md","localizedDate":"2018年12月12日","excerpt":"<h1> [图像处理] YUV图像处理入门4</h1>\\n<h2> 9 yuv420图像截取</h2>\\n<p>本程序中的函数主要是对YUV420P视频数据流的第一帧图像进行截取。类似opencv中的rect函数，函数的代码如下所示：</p>\\n<pre><code>/**\\n * @file 9 yuv_clip.cpp\\n * @author luohen\\n * @brief yuv image clip\\n * @date 2018-12-08\\n *\\n */\\n\\n#include \\"stdafx.h\\"\\n#include &lt;stdio.h&gt;\\n#include &lt;stdlib.h&gt;\\n#include &lt;string.h&gt;\\n#include &lt;math.h&gt;\\n#include &lt;iostream&gt;\\n\\nusing namespace std;\\n\\n/**\\n * @brief\\n *\\n * @param w width of input yuv420p file\\n * @param h height of input yuv420p file\\n * @param sx clipped initial position x of origin y image\\n * @param sy clipped initial position y of origin y image\\n * @param sw wdith of clipped image\\n * @param sh height of clipped image\\n * @param url location of input yuv420p file\\n * @return int\\n */\\nint yuv420_clip(int w, int h, int sx, int sy, int sw, int sh, const char *url)\\n{\\n\\t//reading yuv file\\n\\tFILE *input_fp;\\n\\t//writing yuv file\\n\\tFILE *output_fp = fopen(\\"video_result/output_clip.yuv\\", \\"wb+\\");\\n\\n\\tif ((input_fp = fopen(url, \\"rb\\")) == NULL)\\n\\t{\\n\\t\\tprintf(\\"%s open error!\\\\n\\", url);\\n\\t\\treturn -1;\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tprintf(\\"%s open.\\\\n\\", url);\\n\\t}\\n\\n\\t//origin image\\n\\tunsigned char *pic = new unsigned char[w * h * 3 / 2];\\n\\t//clipped image\\n\\tunsigned char *pic_clip = new unsigned char[sw * sh * 3 / 2];\\n\\n\\t// y length of origin image\\n\\tint size_y = w * h;\\n\\t// yu length of origin image\\n\\tint size_yu = w * h + w * h / 4;\\n\\t// y length of clipped image\\n\\tint size_sy = sw * sh;\\n\\t// yu length of clipped image\\n\\tint size_syu = sw * sh + sw * sh / 4;\\n\\n\\tfread(pic, sizeof(unsigned char), w * h * 3 / 2, input_fp);\\n\\n\\t//y clip\\n\\tfor (int j = 0; j &lt; sh; j++)\\n\\t{\\n\\t\\tfor (int k = 0; k &lt; sw; k++)\\n\\t\\t{\\n\\t\\t\\tpic_clip[j * sw + k] = pic[(sx + j) * w + (sy + k)];\\n\\t\\t}\\n\\t}\\n\\n\\t//sw_uv,sh_uv\\n\\tint sw_uv = sw / 2;\\n\\tint sh_uv = sh / 2;\\n\\n\\t//u clip\\n\\tfor (int j = 0; j &lt; sh_uv; j++)\\n\\t{\\n\\t\\tfor (int k = 0; k &lt; sw_uv; k++)\\n\\t\\t{\\n\\t\\t\\tpic_clip[size_sy + j * sw_uv + k] = pic[size_y + (sx / 2 + j) * w / 2 + (sy / 2 + k)];\\n\\t\\t}\\n\\t}\\n\\n\\t//v clip\\n\\tfor (int j = 0; j &lt; sh_uv; j++)\\n\\t{\\n\\t\\tfor (int k = 0; k &lt; sw_uv; k++)\\n\\t\\t{\\n\\t\\t\\tpic_clip[size_syu + j * sw_uv + k] = pic[size_yu + (sx / 2 + j) * w / 2 + (sy / 2 + k)];\\n\\t\\t}\\n\\t}\\n\\n\\tfwrite(pic_clip, 1, sw * sh * 3 / 2, output_fp);\\n\\n\\tdelete[] pic;\\n\\tdelete[] pic_clip;\\n\\tfclose(input_fp);\\n\\tfclose(output_fp);\\n\\treturn 0;\\n}\\n\\n/**\\n * @brief main\\n *\\n * @return int\\n */\\nint main()\\n{\\n\\tint state = yuv420_clip(352, 288, 60, 50, 176, 144, \\"video/akiyo.yuv\\");\\n\\treturn 0;\\n}\\n</code></pre>","autoDesc":true}');export{t as data};
